// filepath: c:\Users\muniz\Documents\GitHub\starboy\websockets.js
const WebSocket = require('ws');
const { EventEmitter } = require('events');
const crypto = require('crypto');
const nacl = require('tweetnacl');
const { v4: uuidv4 } = require('uuid');
const { getDatabaseInstance } = require('./db/conexao');
const api = require('./api'); // Importar o m√≥dulo api completo
const { getAccountConnectionState } = require('./api'); // Importar fun√ß√£o espec√≠fica

// Vari√°veis para as bibliotecas Ed25519
let nobleEd25519SignFunction = null;
let tweetnaclInstance = null;

// Fun√ß√£o para carregar @noble/ed25519 dinamicamente
async function loadNobleEd25519() {
  if (nobleEd25519SignFunction) return true;
  try {
    const nobleModule = await import('@noble/ed25519');
    if (nobleModule && typeof nobleModule.sign === 'function') {
      nobleEd25519SignFunction = nobleModule.sign;
      console.log('[WS-API] @noble/ed25519 carregado dinamicamente com sucesso.');
      return true;
    }
    console.log('[WS-API] @noble/ed25519 carregado, mas a fun√ß√£o sign n√£o foi encontrada.');
    return false;
  } catch (e) {
    if (e.code !== 'ERR_MODULE_NOT_FOUND') {
        console.warn('[WS-API] Falha ao carregar @noble/ed25519 dinamicamente:', e.message);
    } else {
        console.log('[WS-API] @noble/ed25519 n√£o instalado, pulando.');
    }
    return false;
  }
}

// Carregar tweetnacl
try {
  tweetnaclInstance = require('tweetnacl');
  console.log('[WS-API] tweetnacl carregado com sucesso.');
} catch (e) {
  console.log('[WS-API] tweetnacl n√£o dispon√≠vel, ser√° usado apenas crypto nativo ou @noble/ed25519 (se dispon√≠vel).');
}

const priceWebsocketsByAccount = new Map(); // Mapeia accountId -> { symbol -> websocket }

function getAllAccountConnections() {
  console.warn("[WEBSOCKETS] getAllAccountConnections pode estar retornando dados incompletos. Use getAccountConnectionState de api.js");
  return priceWebsocketsByAccount;
}

// Inicializar mapa de websockets de pre√ßo por conta
function getPriceWebsockets(accountId, create = false) {
  if (!priceWebsocketsByAccount.has(accountId) && create) {
    priceWebsocketsByAccount.set(accountId, new Map());
  }
  return priceWebsocketsByAccount.get(accountId) || new Map();
}

/**
 * Cria assinatura Ed25519.
 */
async function createEd25519Signature(payload, accountId) {
  const accountState = getAccountConnectionState(accountId);
  if (!accountState || !accountState.wsApiSecret) {
    throw new Error(`Chave privada Ed25519 (ws_api_secret no formato PEM) n√£o encontrada para conta ${accountId}`);
  }
  const pemPrivateKey = accountState.wsApiSecret; // Usar wsApiSecret que √© a chave PEM

  console.log(`[WS-API] Gerando assinatura Ed25519 para conta ${accountId}`);
  console.log(`[WS-API] Payload: ${payload}`);

  const payloadBuffer = Buffer.from(payload, 'ascii');

  try {
    if (typeof pemPrivateKey !== 'string' || !pemPrivateKey.includes('-----BEGIN PRIVATE KEY-----')) {
        throw new Error('Chave privada n√£o est√° no formato PEM string esperado.');
    }
    const privateKeyObject = crypto.createPrivateKey({
      key: pemPrivateKey,
      format: 'pem'
    });
    const signatureBuffer = crypto.sign(null, payloadBuffer, privateKeyObject);
    const signature = signatureBuffer.toString('base64');
    console.log(`[WS-API] ‚úÖ Assinatura Ed25519 criada com crypto nativo para conta ${accountId}`);
    return signature;
  } catch (nativeCryptoError) {
    console.warn(`[WS-API] Falha ao assinar com crypto nativo para conta ${accountId}: ${nativeCryptoError.message}. Tentando fallbacks.`);
  }

  function extractRawKeyFromPem(pemKey) {
    try {
      const keyObj = crypto.createPrivateKey({ key: pemKey, format: 'pem' });
      const pkcs8Der = keyObj.export({ format: 'der', type: 'pkcs8' });
      if (pkcs8Der[12] === 0x04 && pkcs8Der[13] === 0x22 && pkcs8Der[14] === 0x04 && pkcs8Der[15] === 0x20) {
        const rawKey = pkcs8Der.subarray(16, 16 + 32);
        if (rawKey.length === 32) return rawKey;
      }
      if (pkcs8Der.length >= 32) {
        const potentialRawKey = pkcs8Der.subarray(-32);
        if (potentialRawKey.length === 32) return potentialRawKey;
      }
      console.warn('[WS-API] N√£o foi poss√≠vel extrair a chave raw de 32 bytes do PEM de forma confi√°vel.');
      return null;
    } catch (e) {
      console.error('[WS-API] Erro ao extrair chave raw do PEM:', e.message);
      return null;
    }
  }

  await loadNobleEd25519();
  if (nobleEd25519SignFunction) {
    try {
      const rawPrivateKey = extractRawKeyFromPem(pemPrivateKey);
      if (!rawPrivateKey) {
        throw new Error('N√£o foi poss√≠vel extrair a chave raw de 32 bytes do PEM para @noble/ed25519.');
      }
      const signatureBytes = nobleEd25519SignFunction(payloadBuffer, rawPrivateKey);
      const signature = Buffer.from(signatureBytes).toString('base64');
      console.log(`[WS-API] ‚úÖ Assinatura Ed25519 criada com @noble/ed25519 para conta ${accountId}`);
      return signature;
    } catch (nobleError) {
      console.warn(`[WS-API] Falha ao assinar com @noble/ed25519 para conta ${accountId}: ${nobleError.message}. Tentando pr√≥ximo fallback.`);
    }
  }

  if (tweetnaclInstance) {
    try {
      const seed = extractRawKeyFromPem(pemPrivateKey);
      if (!seed) {
        throw new Error('N√£o foi poss√≠vel extrair a seed de 32 bytes do PEM para tweetnacl.');
      }
      const keyPair = tweetnaclInstance.sign.keyPair.fromSeed(seed);
      const signatureBytes = tweetnaclInstance.sign.detached(payloadBuffer, keyPair.secretKey);
      const signature = Buffer.from(signatureBytes).toString('base64');
      console.log(`[WS-API] ‚úÖ Assinatura Ed25519 criada com tweetnacl para conta ${accountId}`);
      return signature;
    } catch (naclError) {
      console.error(`[WS-API] Erro ao assinar com tweetnacl para conta ${accountId}: ${naclError.message}. Este foi o √∫ltimo fallback.`);
    }
  }

  const errorMessage = `Falha ao criar assinatura Ed25519 para conta ${accountId}: Todos os m√©todos de assinatura falharam.`;
  console.error(`[WS-API] ${errorMessage}`);
  throw new Error(errorMessage);
}

/**
 * Cria uma requisi√ß√£o assinada para a API WebSocket
 */
async function createSignedRequest(method, params = {}, accountId) {
  const accountState = getAccountConnectionState(accountId);
  if (!accountState) {
    console.warn(`[WS-API] Estado da conta ${accountId} n√£o encontrado em createSignedRequest. Tentando carregar...`);
    await api.loadCredentialsFromDatabase(accountId);
    const newState = getAccountConnectionState(accountId);
    if (!newState) {
      throw new Error(`Estado da conex√£o n√£o encontrado para conta ${accountId} mesmo ap√≥s tentativa de carga.`);
    }
  }
  
  const currentAccountState = getAccountConnectionState(accountId);
  if (!currentAccountState) {
      throw new Error(`Estado da conex√£o n√£o encontrado para conta ${accountId}.`);
  }

  const requestId = uuidv4();
  
  if (method === 'ping' || method === 'pong' || method === 'session.status') {
    return {
      id: requestId,
      method,
      params: params || {}
    };
  }
  
  const requestParams = {
    ...params,
    apiKey: currentAccountState.wsApiKey || currentAccountState.apiKey,
    timestamp: Date.now()
  };
  
  const sortedParams = Object.keys(requestParams)
    .filter(key => key !== 'signature')
    .sort()
    .map(key => `${key}=${requestParams[key]}`)
    .join('&');
  
  console.log(`[WS-API] Payload para assinatura (createSignedRequest): ${sortedParams}`);
  
  const signature = await createEd25519Signature(sortedParams, accountId);
  
  requestParams.signature = signature;
  
  return {
    id: requestId,
    method,
    params: requestParams
  };
}

/**
 * Inicia conex√£o WebSocket API para uma conta
 */
async function startWebSocketApi(accountId) {
  try {
    await api.loadCredentialsFromDatabase(accountId);
    let accountState = getAccountConnectionState(accountId);

    if (!accountState || !accountState.wsApiKey || !accountState.wsApiUrl) {
      console.error(`[WS-API] Credenciais ou URL da WebSocket API n√£o encontradas para conta ${accountId}`);
      return false;
    }

    if (accountState.wsApiConnection && accountState.wsApiConnection.readyState === WebSocket.OPEN) {
      console.log(`[WS-API] Conex√£o WebSocket API j√° est√° ativa para conta ${accountId}`);
      if (accountState.wsApiAuthenticated) {
        return true;
      }
      try {
        console.log(`[WS-API] Tentando re-autenticar conex√£o existente para conta ${accountId}...`);
        const authenticated = await authenticateWebSocketApi(accountState.wsApiConnection, accountId);
        return authenticated;
      } catch (authError) {
        console.error(`[WS-API] Erro ao re-autenticar conex√£o existente para conta ${accountId}: ${authError.message}`);
        cleanupWebSocketApi(accountId);
        return false;
      }
    }

    console.log(`[WS-API] Iniciando WebSocket API para conta ${accountId}...`);
    const endpoint = accountState.wsApiUrl;
    console.log(`[WS-API] Conectando ao endpoint oficial: ${endpoint} para conta ${accountId}`);

    return new Promise((resolve, reject) => {
      const wsInstance = new WebSocket(endpoint);
      accountState.wsApiConnection = wsInstance;

      const connectionTimeout = setTimeout(() => {
        if (wsInstance.readyState !== WebSocket.OPEN && wsInstance.readyState !== WebSocket.CLOSING && wsInstance.readyState !== WebSocket.CLOSED) {
          console.error(`[WS-API] Timeout ao conectar WebSocket API para conta ${accountId}. Estado: ${wsInstance.readyState}`);
          wsInstance.terminate();
          reject(new Error(`Timeout ao conectar WebSocket API para conta ${accountId}`));
        }
      }, 30000);

      wsInstance.on('open', async () => {
        clearTimeout(connectionTimeout);
        console.log(`[WS-API] ‚úÖ Conex√£o WebSocket API estabelecida para conta ${accountId}`);
        
        accountState.lastPongTime = Date.now();

        try {
          const authenticated = await authenticateWebSocketApi(wsInstance, accountId);
          if (authenticated) {
            console.log(`[WS-API] Autentica√ß√£o bem-sucedida para conta ${accountId}. Iniciando keep-alive.`);
            
            if (accountState.pingInterval) clearInterval(accountState.pingInterval);
            accountState.pingInterval = setInterval(() => {
              const currentWsConn = getAccountConnectionState(accountId)?.wsApiConnection;
              if (currentWsConn && currentWsConn.readyState === WebSocket.OPEN) {
                if (Date.now() - (getAccountConnectionState(accountId)?.lastPongTime || 0) > 7 * 60 * 1000) {
                  console.warn(`[WS-API] Nenhum pong recebido do SERVIDOR para conta ${accountId} em 7 minutos. Conex√£o pode estar inst√°vel.`);
                }
                const clientPingId = `client-ping-${Date.now()}-${accountId}`;
                currentWsConn.send(JSON.stringify({ id: clientPingId, method: 'ping' }));
              } else {
                if (accountState.pingInterval) clearInterval(accountState.pingInterval);
                accountState.pingInterval = null;
              }
            }, 3 * 60 * 1000);
            resolve(true);
          } else {
            console.error(`[WS-API] Falha na autentica√ß√£o para conta ${accountId}. Conex√£o ser√° fechada.`);
            wsInstance.close(1008, "Authentication Failed");
            resolve(false);
          }
        } catch (authError) {
          console.error(`[WS-API] Erro durante a autentica√ß√£o para conta ${accountId}:`, authError.message);
          wsInstance.close(1008, "Authentication Error");
          reject(authError);
        }
      });

      wsInstance.on('message', (data) => {
        try {
          const message = JSON.parse(data.toString());
          handleWebSocketApiMessage(message, accountId);
        } catch (e) {
          console.error('[WS-API] Erro ao parsear mensagem JSON:', e, data.toString().substring(0, 500));
        }
      });

      wsInstance.on('error', (error) => {
        clearTimeout(connectionTimeout);
        console.error(`[WS-API] Erro na conex√£o WebSocket API para conta ${accountId}: ${error.message}`);
        reject(error);
      });

      wsInstance.on('close', (code, reason) => {
        clearTimeout(connectionTimeout);
        console.log(`[WS-API] Conex√£o WebSocket API fechada para conta ${accountId}. Code: ${code}, Reason: ${reason ? reason.toString() : 'N/A'}`);
        cleanupWebSocketApi(accountId);
      });
    });

  } catch (error) {
    console.error(`[WS-API] Erro GERAL ao iniciar WebSocket API para conta ${accountId}:`, error.message);
    cleanupWebSocketApi(accountId);
    return false;
  }
}

/**
 * Processa mensagens recebidas via WebSocket API
 */
function handleWebSocketApiMessage(message, accountId) {
    try {
        const accountState = getAccountConnectionState(accountId);
        if (!accountState) {
            console.error(`[WS-API] Estado da conta ${accountId} n√£o encontrado para processar mensagem`);
            return;
        }
        
        if (message.id) {
            const callbackEntry = accountState.wsApiRequestCallbacks.get(message.id);
            
            if (callbackEntry) {
                if (typeof callbackEntry === 'function') {
                    callbackEntry(message);
                } else if (typeof callbackEntry === 'object' && callbackEntry.resolve && callbackEntry.reject && callbackEntry.timer) {
                    clearTimeout(callbackEntry.timer);
                    if (message.error) {
                        callbackEntry.reject(message);
                    } else {
                        callbackEntry.resolve(message);
                    }
                } else {
                    console.warn(`[WS-API] Formato de callback inesperado para ID ${message.id} na conta ${accountId}. Callback:`, callbackEntry);
                }
                accountState.wsApiRequestCallbacks.delete(message.id);
            }
        } else if (message.method === 'ping') {
            console.log(`[WS-API] Ping recebido do servidor para conta ${accountId} (ID: ${message.id || 'N/A'}), enviando pong...`);
            sendPong(message.id, accountId); 
        } else if (message.method === 'pong') {
            console.log(`[WS-API] Pong recebido do servidor para conta ${accountId} (ID: ${message.id || 'N/A'})`);
            accountState.lastPongTime = Date.now();
        } else if (message.e) {
            if (accountState.monitoringCallbacks && accountState.monitoringCallbacks.handleOrderUpdate && message.e === 'ORDER_TRADE_UPDATE') {
                accountState.monitoringCallbacks.handleOrderUpdate(message, accountState.dbInstance, accountId);
            } else if (accountState.monitoringCallbacks && accountState.monitoringCallbacks.handleAccountUpdate && message.e === 'ACCOUNT_UPDATE') {
                 accountState.monitoringCallbacks.handleAccountUpdate(message, accountState.dbInstance, accountId);
            }
        } else {
            console.log(`[WS-API] Mensagem n√£o tratada recebida para conta ${accountId}:`, JSON.stringify(message));
        }
        
    } catch (error) {
        console.error(`[WS-API] Erro ao processar mensagem para conta ${accountId}:`, error.message, error.stack);
        console.error('[WS-API] Mensagem original:', JSON.stringify(message, null, 2));
    }
}

/**
 * Limpa recursos do WebSocket API para uma conta espec√≠fica
 */
function cleanupWebSocketApi(accountId) {
  const accountState = getAccountConnectionState(accountId);
  if (!accountState) return;

  if (accountState.pingInterval) {
    clearInterval(accountState.pingInterval);
    accountState.pingInterval = null;
  }

  const wsConn = accountState.wsApiConnection;
  if (wsConn) {
    wsConn.removeAllListeners('open');
    wsConn.removeAllListeners('message');
    wsConn.removeAllListeners('error');
    wsConn.removeAllListeners('close');
    wsConn.removeAllListeners('ping');
    wsConn.removeAllListeners('pong');

    if (typeof wsConn.terminate === 'function' && 
        (wsConn.readyState === WebSocket.OPEN || wsConn.readyState === WebSocket.CONNECTING)) {
      try {
        wsConn.terminate();
      } catch (e) {
        console.warn(`[WS-API] Erro menor ao terminar wsApiConnection para conta ${accountId}: ${e.message}`);
      }
    }
  }
  accountState.wsApiConnection = null;
  accountState.wsApiAuthenticated = false;
  
  if (accountState.wsApiRequestCallbacks) {
    for (const [id, callbackEntry] of accountState.wsApiRequestCallbacks.entries()) {
      if (callbackEntry && callbackEntry.timer) clearTimeout(callbackEntry.timer);
      if (callbackEntry && typeof callbackEntry.reject === 'function') {
        callbackEntry.reject({ error: 'WebSocket connection closed or cleaned up', id });
      }
    }
    accountState.wsApiRequestCallbacks.clear();
  }
}

/**
 * Envia pong em resposta a ping do servidor
 */
function sendPong(pingId, accountId) {
  const accountState = getAccountConnectionState(accountId);
  if (!accountState || !accountState.wsApiConnection || accountState.wsApiConnection.readyState !== WebSocket.OPEN) {
    return;
  }
  
  try {
    const pongRequest = {
      method: 'pong'
    };
    if (pingId) {
      pongRequest.id = pingId;
    }

    accountState.wsApiConnection.send(JSON.stringify(pongRequest));
  } catch (error) {
    console.error(`[WS-API] Erro ao enviar pong para conta ${accountId}:`, error);
  }
}

/**
 * Verifica o status da sess√£o da WebSocket API
 */
async function checkSessionStatus(accountId) {
  try {
    const request = await createSignedRequest('session.status', {}, accountId);
    const response = await sendWebSocketApiRequest(request, 30000, accountId);
    
    const accountState = true);
    
    if (response && response.result) {
      accountState.wsApiAuthenticated = response.result.apiKey !== null && response.result.authorizedSince > 0;
    } else {
      accountState.wsApiAuthenticated = false;
    }
    
    return response;
  } catch (error) {
    console.error(`[WS-API] Erro ao verificar status da sess√£o para conta ${accountId}:`, error.message || error);
    const accountState = true);
    accountState.wsApiAuthenticated = false;
    return { result: { apiKey: null, authorizedSince: 0, connectedSince: 0 }, error: { message: error.message || 'Erro desconhecido ao verificar status', code: error.code || -1 } };
  }
}

/**
 * Autentica na WebSocket API usando session.logon
 */
async function authenticateWebSocketApi(ws, accountId) {
  try {
    const accountState = getAccountConnectionState(accountId);
    if (!accountState || !accountState.wsApiKey || !accountState.wsApiSecret) {
      throw new Error(`Credenciais WebSocket (apiKey ou privateKey PEM) incompletas para conta ${accountId}`);
    }

    console.log(`[WS-API] Iniciando autentica√ß√£o session.logon para conta ${accountId}...`);

    const timestamp = Date.now();
    const authParams = {
      apiKey: accountState.wsApiKey,
      timestamp: timestamp
    };

    const sortedKeys = Object.keys(authParams).sort();
    const payload = sortedKeys.map(key => `${key}=${authParams[key]}`).join('&');
    
    console.log(`[WS-API] Payload para assinatura (authenticateWebSocketApi): ${payload}`);

    const signature = await createEd25519Signature(payload, accountId);

    const authRequest = {
      id: `auth-${timestamp}-${accountId}`,
      method: 'session.logon',
      params: {
        apiKey: authParams.apiKey,
        signature: signature,
        timestamp: authParams.timestamp
      }
    };

    return new Promise((resolve, reject) => {
      const timeoutDuration = 30000;
      const timeoutId = setTimeout(() => {
        console.error(`[WS-API] Timeout na autentica√ß√£o WebSocket API para conta ${accountId} (ID: ${authRequest.id})`);
        reject(new Error(`Timeout na autentica√ß√£o WebSocket API (ID: ${authRequest.id})`));
      }, timeoutDuration);

      accountState.wsApiRequestCallbacks.set(authRequest.id, (responseMessage) => {
        clearTimeout(timeoutId);
        
        console.log(`[WS-API] Resposta recebida para autentica√ß√£o (ID: ${authRequest.id}):`, JSON.stringify(responseMessage, null, 2));
        
        if (responseMessage.status === 200 && responseMessage.result) {
          console.log(`[WS-API] ‚úÖ Autentica√ß√£o session.logon bem-sucedida para conta ${accountId}`);
          accountState.wsApiAuthenticated = true;
          accountState.isAuthenticated = true;
          resolve(true);
        } else {
          const errorMsg = responseMessage.error?.msg || 'Erro desconhecido na autentica√ß√£o';
          console.error(`[WS-API] Falha na autentica√ß√£o session.logon para conta ${accountId}:`, errorMsg, responseMessage.error);
          reject(new Error(`Falha na autentica√ß√£o session.logon: ${errorMsg} (Code: ${responseMessage.error?.code})`));
        }
      });

      console.log(`[WS-API] Enviando requisi√ß√£o de autentica√ß√£o (ID: ${authRequest.id}):`, JSON.stringify(authRequest, null, 2));
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(authRequest));
      } else {
        clearTimeout(timeoutId);
        accountState.wsApiRequestCallbacks.delete(authRequest.id);
        console.error(`[WS-API] WebSocket n√£o est√° aberto ao tentar enviar autentica√ß√£o para conta ${accountId}. Estado: ${ws.readyState}`);
        reject(new Error('WebSocket n√£o est√° aberto para autentica√ß√£o.'));
      }
    });

  } catch (error) {
    console.error(`[WS-API] Erro cr√≠tico na fun√ß√£o authenticateWebSocketApi para conta ${accountId}:`, error.message);
    throw error;
  }
}

/**
 * Garante que existe um websocket de pre√ßo para o s√≠mbolo
 */
async function ensurePriceWebsocketExists(symbol, accountId) {
  const priceWebsockets = getPriceWebsockets(accountId, true);
  
  if (priceWebsockets.has(symbol) && priceWebsockets.get(symbol).readyState === WebSocket.OPEN) {
    return;
  }

  if (priceWebsockets.has(symbol)) {
    try {
      priceWebsockets.get(symbol).close();
    } catch (e) { /* Ignorar */ }
    priceWebsockets.delete(symbol);
  }

  const accountState = true);
  if (!accountState.wsUrl) {
    await api.loadCredentialsFromDatabase(accountId);
  }
  
  const updatedAccountState = getAccountConnectionState(accountId);
  if (!updatedAccountState || !updatedAccountState.wsUrl) {
      console.error(`[WEBSOCKET] URL de mercado (wsUrl) n√£o encontrada para conta ${accountId} em ensurePriceWebsocketExists.`);
      return;
  }

  console.log(`[WEBSOCKET] Iniciando monitoramento de pre√ßo para ${symbol} (conta ${accountId})`);

  const wsEndpointUrl = `${updatedAccountState.wsUrl}/ws/${symbol.toLowerCase()}@bookTicker`;
  console.log(`[WEBSOCKET] URL para monitoramento de pre√ßo: ${wsEndpointUrl}`);

  const ws = new WebSocket(wsEndpointUrl);

  ws.on('open', () => {
    console.log(`[WEBSOCKET] Conex√£o de pre√ßo aberta para ${symbol} (conta ${accountId})`);
  });

  ws.on('message', async (data) => {
    const tickerData = JSON.parse(data);
    await handlePriceUpdate(symbol, tickerData, accountId);
  });

  ws.on('error', (error) => {
    console.error(`[WEBSOCKET] Erro na conex√£o de pre√ßo para ${symbol} (conta ${accountId}):`, error.message);
    if (priceWebsockets.get(symbol) === ws) {
        priceWebsockets.delete(symbol);
    }
    setTimeout(() => ensurePriceWebsocketExists(symbol, accountId), 5000);
  });

  ws.on('close', (code, reason) => {
    console.log(`[WEBSOCKET] Conex√£o de pre√ßo fechada para ${symbol} (conta ${accountId}). Code: ${code}, Reason: ${reason ? reason.toString() : 'N/A'}`);
    if (priceWebsockets.get(symbol) === ws) {
        priceWebsockets.delete(symbol);
    }
    if (code !== 1000) {
        setTimeout(() => ensurePriceWebsocketExists(symbol, accountId), 5000);
    }
  });

  priceWebsockets.set(symbol, ws);
}

/**
 * Processa atualiza√ß√µes de pre√ßo recebidas via websocket
 */
async function handlePriceUpdate(symbol, tickerData, accountId) {
  try {
    const accountState = true);
    let db = accountState.dbInstance;
    
    if (!db) {
      if (accountState.monitoringCallbacks && accountState.monitoringCallbacks.getDbConnection) {
        try {
          db = await accountState.monitoringCallbacks.getDbConnection();
          accountState.dbInstance = db;
        } catch (dbHandlerError) {
          console.error(`[WEBSOCKETS] Erro ao obter DB via handler para ${symbol}: ${dbHandlerError.message}`);
        }
      }
      
      if (!db) {
        try {
          const { getDatabaseInstance } = require('./db/conexao');
          db = await getDatabaseInstance(accountId);
          accountState.dbInstance = db;
        } catch (directDbError) {
          console.error(`[WEBSOCKETS] Erro ao obter DB diretamente para ${symbol}: ${directDbError.message}`);
        }
      }
    }

    if (!db) {
      console.error(`[WEBSOCKETS] N√£o foi poss√≠vel obter conex√£o com o banco de dados para ${symbol} (conta ${accountId})`);
      return;
    }

    const bestBid = parseFloat(tickerData.b);
    const bestAsk = parseFloat(tickerData.a);
    const currentPrice = (bestBid + bestAsk) / 2;

    if (accountState.monitoringCallbacks && accountState.monitoringCallbacks.onPriceUpdate) {
      await accountState.monitoringCallbacks.onPriceUpdate(symbol, currentPrice, db, accountId);
    }
  } catch (error) {
    console.error(`[WEBSOCKETS] Erro ao processar atualiza√ß√£o de pre√ßo para ${symbol} (conta ${accountId}):`, error);
  }
}

/**
 * Configura websocket para monitoramento de BookTicker
 */
function setupBookDepthWebsocket(symbol, callback, accountId) {
  const accountState = true);
  
  const wsEndpoint = `${accountState.wsUrl}/${symbol.toLowerCase()}@bookTicker`;
  console.log(`[WEBSOCKET] Conectando ao BookTicker em tempo real: ${wsEndpoint} (conta ${accountId})`);
  
  let ws = new WebSocket(wsEndpoint);
  let connectionTimeout = null;
  let heartbeatInterval = null;
  let reconnectAttempt = 0;
  const MAX_RECONNECT_ATTEMPTS = 5;

  connectionTimeout = setTimeout(() => {
    if (ws.readyState !== WebSocket.OPEN) {
      console.error(`[WEBSOCKETS] Timeout ao estabelecer conex√£o para ${symbol} BookTicker (conta ${accountId})`);
      ws.terminate();
    }
  }, 10000);

  ws.on('open', () => {
    console.log(`[WEBSOCKET] BookTicker WebSocket conectado para ${symbol} (conta ${accountId})`);
    clearTimeout(connectionTimeout);
    reconnectAttempt = 0;

    heartbeatInterval = setInterval(() => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.ping();
      }
    }, 15000);
  });
  
  ws.on('message', (data) => {
    try {
      const tickerData = JSON.parse(data);
      
      if (tickerData && 
          (tickerData.e === 'bookTicker' || tickerData.e === undefined) && 
          typeof tickerData.b === 'string' && 
          typeof tickerData.a === 'string') {
        
        const bestBid = parseFloat(tickerData.b);
        const bestAsk = parseFloat(tickerData.a);
        const bestBidQty = parseFloat(tickerData.B || '0');
        const bestAskQty = parseFloat(tickerData.A || '0');
        
        if (!isNaN(bestBid) && !isNaN(bestAsk) && bestBid > 0 && bestAsk > 0) {
          callback({
            bestBid, 
            bestAsk,
            bestBidQty,
            bestAskQty,
            timestamp: tickerData.E || Date.now()
          });
        } else {
          console.log(`[WEBSOCKET] Valores num√©ricos inv√°lidos em BookTicker para ${symbol} (conta ${accountId}): bid=${bestBid}, ask=${bestAsk}`);
        }
      } else {
        console.log(`[WEBSOCKET] Formato inesperado de dados BookTicker para ${symbol} (conta ${accountId})`);
      }
    } catch (error) {
      console.error(`[WEBSOCKET] Erro ao processar BookTicker para ${symbol} (conta ${accountId}):`, error.message);
    }
  });
  
  ws.on('error', (error) => {
    clearTimeout(connectionTimeout);
    clearInterval(heartbeatInterval);
    console.error(`[WEBSOCKET] Erro na conex√£o BookTicker para ${symbol} (conta ${accountId}):`, error.message);
  });
  
  ws.on('close', () => {
    clearTimeout(connectionTimeout);
    clearInterval(heartbeatInterval);
    console.log(`[WEBSOCKET] BookTicker WebSocket fechado para ${symbol} (conta ${accountId})`);
  });
  
  return ws;
}

/**
 * Interrompe o monitoramento de pre√ßo para um s√≠mbolo
 */
function stopPriceMonitoring(symbol, accountId) {
  const priceWebsockets = getPriceWebsockets(accountId);
  if (!priceWebsockets) return false;
  
  if (priceWebsockets.has(symbol)) {
    console.log(`[WEBSOCKET] Fechando websocket de pre√ßo para ${symbol} (conta ${accountId}) por solicita√ß√£o externa`);
    priceWebsockets.get(symbol).close();
    priceWebsockets.delete(symbol);
    return true;
  }
  return false;
}

/**
 * Inicia stream de dados do usu√°rio para uma conta
 */
async function startUserDataStream(db, accountId) {
  const accountState = true); 

  if (accountState.userDataStream && accountState.userDataStream.readyState === WebSocket.OPEN) {
    console.log(`[WEBSOCKET] UserDataStream j√° est√° ativo para conta ${accountId}`);
    return;
  }

  console.log(`[WEBSOCKETS] Iniciando stream de dados do usu√°rio para conta ${accountId}...`);
  
  let listenKey;
  try {
    listenKey = await api.getListenKey(accountId);
  } catch (e) {
    console.error(`[WEBSOCKETS] Erro cr√≠tico ao obter listenKey para conta ${accountId}: ${e.message}`);
    throw e;
  }

  if (!listenKey) {
    throw new Error(`Falha ao obter ListenKey para conta ${accountId}`);
  }

  const wsUrl = accountState.wsUrl;
  if (!wsUrl) {
    throw new Error(`URL base do WebSocket (wsUrl) n√£o definida para conta ${accountId}`);
  }
  
  const userDataEndpoint = `${wsUrl}/ws/${listenKey}`;
  console.log(`[WEBSOCKETS] Conectando UserDataStream para conta ${accountId}: ${userDataEndpoint}`);
  
  const ws = new WebSocket(userDataEndpoint);
  accountState.userDataStream = ws;
  accountState.listenKey = listenKey; 
  accountState.lastUserDataStreamKeepAlive = Date.now();

  ws.on('open', () => {
    console.log(`[WEBSOCKET] UserDataStream conectado para conta ${accountId}`);
    if (accountState.userDataKeepAliveInterval) {
      clearInterval(accountState.userDataKeepAliveInterval);
    }
    accountState.userDataKeepAliveInterval = setInterval(async () => {
      if (ws.readyState === WebSocket.OPEN && accountState.listenKey) {
        try {
          await api.keepAliveListenKey(accountId, accountState.listenKey);
          accountState.lastUserDataStreamKeepAlive = Date.now();
        } catch (kaError) {
          console.error(`[WEBSOCKET] Erro ao renovar listenKey para conta ${accountId}: ${kaError.message}`);
        }
      } else {
        if(accountState.userDataKeepAliveInterval) clearInterval(accountState.userDataKeepAliveInterval);
        accountState.userDataKeepAliveInterval = null;
      }
    }, 20 * 60 * 1000);
  });

  ws.on('message', async (data) => {
    try {
        await handleUserDataMessage(data, accountId, db);
    } catch (e) {
        console.error(`[WEBSOCKET] Erro CR√çTICO no handler de mensagem UserDataStream para conta ${accountId}: ${e.message}`);
    }
  });

  ws.on('ping', () => {
    ws.pong();
  });
  
  ws.on('pong', () => {
    accountState.lastUserDataStreamKeepAlive = Date.now();
  });

  ws.on('error', (error) => {
    console.error(`[WEBSOCKET] Erro no UserDataStream para conta ${accountId}: ${error.message}`);
    if (accountState.userDataStream === ws) {
        accountState.userDataStream = null;
    }
    if (accountState.userDataKeepAliveInterval) {
        clearInterval(accountState.userDataKeepAliveInterval);
        accountState.userDataKeepAliveInterval = null;
    }
  });

  ws.on('close', (code, reason) => {
    const reasonStr = reason ? reason.toString() : 'N/A';
    console.log(`[WEBSOCKET] UserDataStream fechado para conta ${accountId}. Code: ${code}, Reason: ${reasonStr}`);
    if (accountState.userDataStream === ws) {
        accountState.userDataStream = null;
    }
    if (accountState.userDataKeepAliveInterval) {
        clearInterval(accountState.userDataKeepAliveInterval);
        accountState.userDataKeepAliveInterval = null;
    }
  });
}

async function handleUserDataMessage(jsonData, accountId, db) {
  const accountState = getAccountConnectionState(accountId);
  if (!accountState || !accountState.monitoringCallbacks) {
    console.error(`[WEBSOCKET] Callbacks de monitoramento n√£o encontrados para conta ${accountId} em handleUserDataMessage.`);
    return;
  }

  const { handleOrderUpdate, handleAccountUpdate } = accountState.monitoringCallbacks;

  try {
    const message = JSON.parse(jsonData.toString());

    if (message.e) {
      switch (message.e) {
        case 'ORDER_TRADE_UPDATE':
          if (handleOrderUpdate && typeof handleOrderUpdate === 'function') {
            await handleOrderUpdate(message, db);
          } else {
            console.warn(`[WEBSOCKET] handleOrderUpdate n√£o definido ou n√£o √© uma fun√ß√£o para conta ${accountId}`);
          }
          break;
        case 'ACCOUNT_UPDATE':
          if (handleAccountUpdate && typeof handleAccountUpdate === 'function') {
            await handleAccountUpdate(message, db);
          } else {
            console.warn(`[WEBSOCKET] handleAccountUpdate n√£o definido ou n√£o √© uma fun√ß√£o para conta ${accountId}`);
          }
          break;
        case 'listenKeyExpired':
          console.log(`[WEBSOCKET] UserDataStream (Conta ${accountId}) ListenKey expirou. Tentando renovar...`);
          await stopUserDataStream(accountId); 
          await startUserDataStream(db, accountId);
          break;
        default:
          break;
      }
    }
  } catch (error) {
    console.error(`[WEBSOCKET] Erro ao processar mensagem UserDataStream para conta ${accountId}: ${error.message}. Dados:`, jsonData.toString().substring(0, 500));
  }
}

function stopUserDataStream(accountId) {
  const accountState = getAccountConnectionState(accountId);
  if (!accountState) return;
  
  if (accountState.userDataStream) {
    accountState.userDataStream.close();
    accountState.userDataStream = null;
  }
  
  if (accountState.userDataKeepAliveInterval) {
    clearInterval(accountState.userDataKeepAliveInterval);
    accountState.userDataKeepAliveInterval = null;
  }
}

function restartUserDataStream(db, accountId) {
  const accountState = getAccountConnectionState(accountId);
  if (!accountState) return;
  
  if (accountState.userDataKeepAliveInterval) {
    clearInterval(accountState.userDataKeepAliveInterval);
    accountState.userDataKeepAliveInterval = null;
  }
  
  setTimeout(async () => {
    try {
      await startUserDataStream(db, accountId);
    } catch (error) {
      console.error(`[WEBSOCKETS] Erro ao reiniciar stream de dados do usu√°rio para conta ${accountId}:`, error);
    }
  }, 5000);
}

function setMonitoringCallbacks(callbackHandlers, accountId) {
  const accountState = true);
  accountState.monitoringCallbacks = { ...accountState.monitoringCallbacks, ...callbackHandlers };
  return accountState.monitoringCallbacks;
}

function getHandlers(accountId) {
  const accountState = getAccountConnectionState(accountId);
  return accountState ? accountState.monitoringCallbacks : {};
}

function getCredentials(accountId) {
  const accountState = getAccountConnectionState(accountId);
  if (!accountState) {
    console.warn(`[WEBSOCKETS] Estado da conta ${accountId} n√£o encontrado em getCredentials. Tente carregar primeiro.`);
    return null;
  }
  
  return {
    accountId: accountState.accountId,
    accountName: accountState.nomeConta,
    apiKey: accountState.apiKey,
    secretKey: accountState.secretKey,
    wsApiKey: accountState.wsApiKey,
    wsApiSecret: accountState.wsApiSecret,
    privateKey: accountState.wsApiSecret,
    apiUrl: accountState.apiUrl,
    wsUrl: accountState.wsUrl,
    wsApiUrl: accountState.wsApiUrl,
    environment: accountState.ambiente,
    broker: accountState.corretora,
  };
}

async function ensureWebSocketApiExists(accountId) {
  try {
    if (!accountId || typeof accountId !== 'number') {
      console.error(`[WEBSOCKETS] ID da conta inv√°lido em ensureWebSocketApiExists: ${accountId}`);
      return false;
    }

    let accountState = getAccountConnectionState(accountId);
    
    if (!accountState || !accountState.wsApiKey) {
      try {
        await api.loadCredentialsFromDatabase(accountId);
        accountState = getAccountConnectionState(accountId);
        
        if (!accountState || !accountState.wsApiKey) {
          console.error(`[WEBSOCKETS] Falha ao carregar credenciais ou wsApiKey ausente para conta ${accountId}.`);
          return false;
        }
      } catch (credError) {
        console.error(`[WEBSOCKETS] Erro ao carregar credenciais para conta ${accountId} em ensureWebSocketApiExists:`, credError.message);
        return false;
      }
    }

    if (accountState.wsApiConnection && accountState.wsApiConnection.readyState === WebSocket.OPEN) {
      if (accountState.wsApiAuthenticated) {
        return true;
      } else {
        console.log(`[WEBSOCKETS] WebSocket API conectado mas n√£o autenticado para conta ${accountId}, tentando autenticar...`);
        return await authenticateWebSocketApi(accountState.wsApiConnection, accountId);
      }
    }

    console.log(`[WEBSOCKETS] Criando nova conex√£o WebSocket API para conta ${accountId}...`);
    return await startWebSocketApi(accountId);
    
  } catch (error) {
    console.error(`[WEBSOCKETS] Erro ao garantir WebSocket API para conta ${accountId}:`, error.message);
    return false;
  }
}

function isWebSocketApiConnected(accountId) {
  const accountState = getAccountConnectionState(accountId);
  if (!accountState) return false;
  
  return accountState.wsApiConnection && 
         accountState.wsApiConnection.readyState === WebSocket.OPEN;
}

function isWebSocketApiAuthenticated(accountId) {
  const accountState = getAccountConnectionState(accountId);
  if (!accountState) return false;
  
  return accountState.wsApiAuthenticated === true;
}

function reset(accountId) {
  forceCleanupAccount(accountId);
}

async function sendWebSocketApiRequest(request, timeout = 30000, accountId) {
  const accountState = getAccountConnectionState(accountId);

  if (!accountState) {
    try {
      await api.loadCredentialsFromDatabase(accountId);
      const newState = getAccountConnectionState(accountId);
      if (!newState) {
        return Promise.reject(new Error(`[WS-API] Estado da conta ${accountId} n√£o p√¥de ser inicializado.`));
      }
    } catch (loadErr) {
      return Promise.reject(new Error(`[WS-API] Falha ao carregar credenciais para conta ${accountId} antes de enviar requisi√ß√£o: ${loadErr.message}`));
    }
  }
  
  const currentAccountState = getAccountConnectionState(accountId);
  if (!currentAccountState) {
      return Promise.reject(new Error(`[WS-API] Estado da conta ${accountId} n√£o encontrado ap√≥s tentativa de carga.`));
  }

  if (!currentAccountState.wsApiConnection || currentAccountState.wsApiConnection.readyState !== WebSocket.OPEN) {
    console.log(`[WS-API] Conex√£o WebSocket API n√£o est√° aberta para conta ${accountId}. Tentando estabelecer...`);
    try {
      const connected = await startWebSocketApi(accountId);
      if (!connected || !currentAccountState.wsApiConnection || currentAccountState.wsApiConnection.readyState !== WebSocket.OPEN) {
        throw new Error('Falha ao estabelecer conex√£o WebSocket API.');
      }
      console.log(`[WS-API] Conex√£o WebSocket API restabelecida para conta ${accountId}.`);
    } catch (connError) {
      console.error(`[WS-API] Erro ao tentar (re)estabelecer conex√£o WebSocket API para conta ${accountId}: ${connError.message}`);
      return Promise.reject(new Error(`[WS-API] WebSocket API n√£o conectado para conta ${accountId}: ${connError.message}`));
    }
  }

  const requestId = request.id || uuidv4();
  request.id = requestId;

  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      if (currentAccountState.wsApiRequestCallbacks.has(requestId)) {
        currentAccountState.wsApiRequestCallbacks.delete(requestId);
        console.error(`[WS-API] Timeout para requisi√ß√£o ID ${requestId} (Conta: ${accountId}, M√©todo: ${request.method})`);
        reject({ error: `Timeout para requisi√ß√£o ${requestId}`, id: requestId, method: request.method });
      }
    }, timeout);

    currentAccountState.wsApiRequestCallbacks.set(requestId, { resolve, reject, timer });

    try {
      const requestString = JSON.stringify(request);
      if (currentAccountState.wsApiConnection.readyState === WebSocket.OPEN) {
        currentAccountState.wsApiConnection.send(requestString);
      } else {
        clearTimeout(timer);
        currentAccountState.wsApiRequestCallbacks.delete(requestId);
        console.error(`[WS-API] Conex√£o fechou antes de enviar req ID ${requestId} (Conta: ${accountId})`);
        reject(new Error(`WebSocket API connection closed before sending request ${requestId} for account ${accountId}.`));
      }
    } catch (error) {
      clearTimeout(timer);
      currentAccountState.wsApiRequestCallbacks.delete(requestId);
      console.error(`[WS-API] Erro ao enviar requisi√ß√£o ID ${requestId} (Conta: ${accountId}):`, error);
      reject({ error: `Erro ao enviar requisi√ß√£o: ${error.message}`, id: requestId, method: request.method });
    }
  });
}

function createEd25519DERFromRaw(rawKey) {
    const ed25519OID = Buffer.from('302a300506032b657004200420', 'hex');
    const derKey = Buffer.concat([ed25519OID, rawKey]);
    return derKey;
}

function forceCleanupAccount(accountId) {
  console.log(`[WEBSOCKET] üßπ Limpeza completa para conta ${accountId}...`);
  
  try {
    cleanupWebSocketApi(accountId);
    
    const priceWebsockets = getPriceWebsockets(accountId);
    if (priceWebsockets) {
      for (const [symbol, ws] of priceWebsockets.entries()) {
        if (ws && ws.readyState !== WebSocket.CLOSED) {
          ws.close(1000, 'Graceful shutdown');
        }
      }
      priceWebsockets.clear();
    }
    
    const accountState = 'Graceful shutdown');
      }
      
      if (accountState.userDataKeepAliveInterval) {
        clearInterval(accountState.userDataKeepAliveInterval);
        accountState.userDataKeepAliveInterval = null;
      }
    }
    
    console.log(`[WEBSOCKETS] ‚úÖ Limpeza completa conclu√≠da para conta ${accountId}`);
    
  } catch (error) {
    console.error(`[WEBSOCKETS] ‚ùå Erro durante limpeza da conta ${accountId}:`, error.message);
  }
}

module.exports = {
  startUserDataStream,
  setupBookDepthWebsocket,
  ensurePriceWebsocketExists,
  stopPriceMonitoring,
  reset,
  startWebSocketApi,
  authenticateWebSocketApi,
  sendWebSocketApiRequest,
  createSignedRequest,
  checkSessionStatus,
  cleanupWebSocketApi,
  isWebSocketApiAuthenticated,
  isWebSocketApiConnected,
  setMonitoringCallbacks,
  getHandlers,
  getCredentials,
  ensureWebSocketApiExists,
  getAllAccountConnections,
  handleWebSocketApiMessage,
  createEd25519Signature,
  createEd25519DERFromRaw,
  forceCleanupAccount,
  loadNobleEd25519,
};
