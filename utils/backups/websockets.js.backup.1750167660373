const WebSocket = require('ws');
const { EventEmitter } = require('events');
const crypto = require('crypto');
const nacl = require('tweetnacl');
const { v4: uuidv4 } = require('uuid');
const { getDatabaseInstance } = require('./db/conexao');
// Importar o m√≥dulo api completo e fun√ß√µes espec√≠ficas que voc√™ j√° usa
const api = require('./api'); // Adicionado para acesso geral √†s fun√ß√µes da api
const { getAccountConnectionState } = require('./api');

// Vari√°veis para as bibliotecas Ed25519
let nobleEd25519SignFunction = null;
// tweetnaclInstance √© carregado abaixo

// Fun√ß√£o para carregar @noble/ed25519 dinamicamente
async function loadNobleEd25519() {
  if (nobleEd25519SignFunction) return true; // J√° carregado
  try {
    const nobleModule = await import('@noble/ed25519');
    if (nobleModule && typeof nobleModule.sign === 'function') {
      nobleEd25519SignFunction = nobleModule.sign;
      console.log('[WS-API] @noble/ed25519 carregado dinamicamente com sucesso.');
      return true;
    }
    console.log('[WS-API] @noble/ed25519 carregado, mas a fun√ß√£o sign n√£o foi encontrada.');
    return false;
  } catch (e) {
    if (e.code !== 'ERR_MODULE_NOT_FOUND') {
        console.warn('[WS-API] Falha ao carregar @noble/ed25519 dinamicamente:', e.message);
    } else {
        console.log('[WS-API] @noble/ed25519 n√£o instalado, pulando.');
    }
    return false;
  }
}

// Carregar tweetnacl (CommonJS, pode ser require direto)
let tweetnaclInstance = null; // Definido aqui para escopo do m√≥dulo
try {
  tweetnaclInstance = require('tweetnacl');
  console.log('[WS-API] tweetnacl carregado com sucesso.');
} catch (e) {
  console.log('[WS-API] tweetnacl n√£o dispon√≠vel, ser√° usado apenas crypto nativo ou @noble/ed25519 (se dispon√≠vel).');
}

// REMOVIDO: Cache de credenciais local, deve ser gerenciado por api.js
// const accountCredentialsCache = new Map();

// REMOVIDO: Mapa de conex√µes principal local, getAccountConnectionState de api.js √© usado
// const accountConnections = new Map(); 

const priceWebsocketsByAccount = new Map(); // Mapeia accountId -> { symbol -> websocket }

function getAllAccountConnections() {
  // Esta fun√ß√£o pode precisar ser repensada. Se api.js gerencia accountConnections,
  // talvez api.js deva exportar uma fun√ß√£o similar ou esta fun√ß√£o deve chamar api.js.
  // Por enquanto, se refere a um mapa local que n√£o √© mais o principal.
  // Se a inten√ß√£o √© obter o estado gerenciado por api.js, isso precisa ser ajustado.
  // Para este ajuste, vamos assumir que se refere ao priceWebsocketsByAccount ou que ser√° removida/ajustada depois.
  // Se for para obter todos os estados de conta, deveria ser algo como:
  // return api.getAllAccountStates(); // Supondo que api.js exporte tal fun√ß√£o
  console.warn("[WEBSOCKETS] getAllAccountConnections pode estar retornando dados incompletos ou desatualizados.");
  return priceWebsocketsByAccount; // Retornando o mapa de websockets de pre√ßo por enquanto
}

// Inicializar mapa de websockets de pre√ßo por conta
function getPriceWebsockets(accountId, create = false) {
  if (!priceWebsocketsByAccount.has(accountId) && create) {
    priceWebsocketsByAccount.set(accountId, new Map());
  }
  return priceWebsocketsByAccount.get(accountId) || new Map();
}

/**
 * Cria assinatura Ed25519.
 * Prioriza crypto nativo, depois @noble/ed25519, depois tweetnacl.
 * @param {string} payload - Payload para assinar
 * @param {number} accountId - ID da conta
 * @returns {Promise<string>} - Assinatura em base64
 */
async function createEd25519Signature(payload, accountId) {
  const accountState = getAccountConnectionState(accountId); // Usa a importada de api.js
  if (!accountState || !accountState.privateKey) { // privateKey deve ser a chave PEM string
    throw new Error(`Chave privada Ed25519 (ws_api_secret no formato PEM) n√£o encontrada para conta ${accountId}`);
  }
  const pemPrivateKey = accountState.privateKey;

  // console.log(`[WS-API] Gerando assinatura Ed25519 para conta ${accountId}`);
  // console.log(`[WS-API] Payload: ${payload}`);

  const payloadBuffer = Buffer.from(payload, 'ascii');

  try {
    if (typeof pemPrivateKey !== 'string' || !pemPrivateKey.includes('-----BEGIN PRIVATE KEY-----')) {
        throw new Error('Chave privada n√£o est√° no formato PEM string esperado.');
    }
    const privateKeyObject = crypto.createPrivateKey({
      key: pemPrivateKey,
      format: 'pem'
    });
    const signatureBuffer = crypto.sign(null, payloadBuffer, privateKeyObject);
    const signature = signatureBuffer.toString('base64');
    // console.log(`[WS-API] ‚úÖ Assinatura Ed25519 criada com crypto nativo para conta ${accountId}`);
    return signature;
  } catch (nativeCryptoError) {
    console.warn(`[WS-API] Falha ao assinar com crypto nativo para conta ${accountId}: ${nativeCryptoError.message}. Tentando fallbacks.`);
  }

  function extractRawKeyFromPem(pemKey) {
    try {
      const keyObj = crypto.createPrivateKey({ key: pemKey, format: 'pem' });
      const pkcs8Der = keyObj.export({ format: 'der', type: 'pkcs8' });
      if (pkcs8Der[12] === 0x04 && pkcs8Der[13] === 0x22 && pkcs8Der[14] === 0x04 && pkcs8Der[15] === 0x20) {
        const rawKey = pkcs8Der.subarray(16, 16 + 32);
        if (rawKey.length === 32) return rawKey;
      }
      if (pkcs8Der.length >= 32) { // Fallback mais simples
        const potentialRawKey = pkcs8Der.subarray(-32);
        if (potentialRawKey.length === 32) return potentialRawKey;
      }
      console.warn('[WS-API] N√£o foi poss√≠vel extrair a chave raw de 32 bytes do PEM de forma confi√°vel.');
      return null;
    } catch (e) {
      console.error('[WS-API] Erro ao extrair chave raw do PEM:', e.message);
      return null;
    }
  }

  await loadNobleEd25519();
  if (nobleEd25519SignFunction) {
    try {
      const rawPrivateKey = extractRawKeyFromPem(pemPrivateKey);
      if (!rawPrivateKey) {
        throw new Error('N√£o foi poss√≠vel extrair a chave raw de 32 bytes do PEM para @noble/ed25519.');
      }
      const signatureBytes = nobleEd25519SignFunction(payloadBuffer, rawPrivateKey);
      const signature = Buffer.from(signatureBytes).toString('base64');
      // console.log(`[WS-API] ‚úÖ Assinatura Ed25519 criada com @noble/ed25519 para conta ${accountId}`);
      return signature;
    } catch (nobleError) {
      console.warn(`[WS-API] Falha ao assinar com @noble/ed25519 para conta ${accountId}: ${nobleError.message}. Tentando pr√≥ximo fallback.`);
    }
  }

  if (tweetnaclInstance) {
    try {
      // tweetnacl.sign.detached precisa da chave secreta completa de 64 bytes (seed + chave p√∫blica)
      // ou apenas da seed de 32 bytes se usar tweetnacl.sign.keyPair.fromSeed para gerar o par.
      // A chave PEM PKCS#8 cont√©m a seed de 32 bytes.
      const seed = extractRawKeyFromPem(pemPrivateKey);
      if (!seed) {
        throw new Error('N√£o foi poss√≠vel extrair a seed de 32 bytes do PEM para tweetnacl.');
      }
      const keyPair = tweetnaclInstance.sign.keyPair.fromSeed(seed);
      const signatureBytes = tweetnaclInstance.sign.detached(payloadBuffer, keyPair.secretKey);
      const signature = Buffer.from(signatureBytes).toString('base64');
      // console.log(`[WS-API] ‚úÖ Assinatura Ed25519 criada com tweetnacl para conta ${accountId}`);
      return signature;
    } catch (naclError) {
      console.error(`[WS-API] Erro ao assinar com tweetnacl para conta ${accountId}: ${naclError.message}. Este foi o √∫ltimo fallback.`);
    }
  }

  const errorMessage = `Falha ao criar assinatura Ed25519 para conta ${accountId}: Todos os m√©todos de assinatura falharam.`;
  console.error(`[WS-API] ${errorMessage}`);
  throw new Error(errorMessage);
}

/**
 * Cria uma requisi√ß√£o assinada para a API WebSocket
 * @param {string} method - M√©todo da API
 * @param {Object} params - Par√¢metros da requisi√ß√£o
 * @param {number} accountId - ID da conta
 * @returns {Promise<Object>} - Requisi√ß√£o pronta para envio (Promise por causa da assinatura async)
 */
async function createSignedRequest(method, params = {}, accountId) { // Tornar async
  const accountState = getAccountConnectionState(accountId);
  if (!accountState) {
    // Tentar carregar credenciais se o estado n√£o existir
    console.warn(`[WS-API] Estado da conta ${accountId} n√£o encontrado em createSignedRequest. Tentando carregar...`);
    await api.loadCredentialsFromDatabase(accountId); // Usa api.js
    const newState = getAccountConnectionState(accountId);
    if (!newState) {
      throw new Error(`Estado da conex√£o n√£o encontrado para conta ${accountId} mesmo ap√≥s tentativa de carga.`);
    }
    // Continuar com newState, mas a l√≥gica abaixo j√° pega o accountState atualizado
  }
  
  const currentAccountState = getAccountConnectionState(accountId); // Re-obter
  if (!currentAccountState) {
      throw new Error(`Estado da conex√£o n√£o encontrado para conta ${accountId}.`);
  }

  const requestId = uuidv4();
  
  if (method === 'ping' || method === 'pong' || method === 'session.status') {
    return {
      id: requestId,
      method,
      params: params || {}
    };
  }
  
  const requestParams = {
    ...params,
    apiKey: currentAccountState.wsApiKey || currentAccountState.apiKey,
    timestamp: Date.now()
  };
  
  const sortedParams = Object.keys(requestParams)
    .filter(key => key !== 'signature')
    .sort()
    .map(key => `${key}=${requestParams[key]}`)
    .join('&');
  
  // console.log(`[WS-API] Payload para assinatura (createSignedRequest): ${sortedParams}`);
  
  const signature = await createEd25519Signature(sortedParams, accountId); // Adicionado await
  
  requestParams.signature = signature;
  
  return {
    id: requestId,
    method,
    params: requestParams
  };
}

/**
 * Inicia conex√£o WebSocket API para uma conta
 * @param {number} accountId - ID da conta
 * @returns {Promise<boolean>} - true se conectado com sucesso
 */
async function startWebSocketApi(accountId) {
  try {
    await api.loadCredentialsFromDatabase(accountId); // Usa api.js
    let accountState = getAccountConnectionState(accountId);

    if (!accountState || !accountState.wsApiKey || !accountState.wsApiUrl) {
      console.error(`[WS-API] Credenciais ou URL da WebSocket API n√£o encontradas para conta ${accountId}`);
      return false;
    }

    if (accountState.wsApiConnection && accountState.wsApiConnection.readyState === WebSocket.OPEN) {
      console.log(`[WS-API] Conex√£o WebSocket API j√° est√° ativa para conta ${accountId}`);
      if (accountState.wsApiAuthenticated) {
        return true;
      }
      try {
        console.log(`[WS-API] Tentando re-autenticar conex√£o existente para conta ${accountId}...`);
        const authenticated = await authenticateWebSocketApi(accountState.wsApiConnection, accountId);
        return authenticated;
      } catch (authError) {
        console.error(`[WS-API] Erro ao re-autenticar conex√£o existente para conta ${accountId}: ${authError.message}`);
        cleanupWebSocketApi(accountId); // Limpa o estado problem√°tico
        return false; // Indica falha na re-autentica√ß√£o
      }
    }

    console.log(`[WS-API] Iniciando WebSocket API para conta ${accountId}...`);
    const endpoint = accountState.wsApiUrl;
    console.log(`[WS-API] Conectando ao endpoint oficial: ${endpoint} para conta ${accountId}`);

    return new Promise((resolve, reject) => {
      const wsInstance = new WebSocket(endpoint);
      accountState.wsApiConnection = wsInstance; // Atribuir ao estado imediatamente

      const connectionTimeout = setTimeout(() => {
        if (wsInstance.readyState !== WebSocket.OPEN && wsInstance.readyState !== WebSocket.CLOSING && wsInstance.readyState !== WebSocket.CLOSED) {
          console.error(`[WS-API] Timeout ao conectar WebSocket API para conta ${accountId}. Estado: ${wsInstance.readyState}`);
          wsInstance.terminate(); // For√ßa o fechamento
          // cleanupWebSocketApi(accountId); // O 'close' handler j√° deve chamar cleanup
          reject(new Error(`Timeout ao conectar WebSocket API para conta ${accountId}`));
        }
      }, 30000); // 30 segundos

      wsInstance.on('open', async () => {
        clearTimeout(connectionTimeout);
        console.log(`[WS-API] ‚úÖ Conex√£o WebSocket API estabelecida para conta ${accountId}`);
        
        // accountState.wsApiConnection = wsInstance; // J√° atribu√≠do acima
        accountState.lastPongTime = Date.now(); // Para keep-alive do cliente

        try {
          const authenticated = await authenticateWebSocketApi(wsInstance, accountId);
          if (authenticated) {
            console.log(`[WS-API] Autentica√ß√£o bem-sucedida para conta ${accountId}. Iniciando keep-alive.`);
            
            if (accountState.pingInterval) clearInterval(accountState.pingInterval);
            accountState.pingInterval = setInterval(() => {
              const currentWsConn = getAccountConnectionState(accountId)?.wsApiConnection;
              if (currentWsConn && currentWsConn.readyState === WebSocket.OPEN) {
                if (Date.now() - (getAccountConnectionState(accountId)?.lastPongTime || 0) > 7 * 60 * 1000) {
                  console.warn(`[WS-API] Nenhum pong recebido do SERVIDOR para conta ${accountId} em 7 minutos. Conex√£o pode estar inst√°vel.`);
                }
                const clientPingId = `client-ping-${Date.now()}-${accountId}`;
                currentWsConn.send(JSON.stringify({ id: clientPingId, method: 'ping' }));
              } else {
                if (accountState.pingInterval) clearInterval(accountState.pingInterval);
                accountState.pingInterval = null;
              }
            }, 3 * 60 * 1000); // A cada 3 minutos
            resolve(true);
          } else {
            console.error(`[WS-API] Falha na autentica√ß√£o para conta ${accountId}. Conex√£o ser√° fechada.`);
            wsInstance.close(1008, "Authentication Failed");
            resolve(false); // Resolveu, mas com falha na autentica√ß√£o
          }
        } catch (authError) {
          console.error(`[WS-API] Erro durante a autentica√ß√£o para conta ${accountId}:`, authError.message);
          wsInstance.close(1008, "Authentication Error");
          reject(authError); // Rejeita a promessa de startWebSocketApi
        }
      });

      wsInstance.on('message', (data) => {
        try {
          const message = JSON.parse(data.toString());
          handleWebSocketApiMessage(message, accountId);
        } catch (e) {
          console.error('[WS-API] Erro ao parsear mensagem JSON:', e, data.toString().substring(0, 500));
        }
      });

      wsInstance.on('error', (error) => {
        clearTimeout(connectionTimeout);
        console.error(`[WS-API] Erro na conex√£o WebSocket API para conta ${accountId}: ${error.message}`);
        // cleanupWebSocketApi(accountId); // O 'close' handler j√° chama
        reject(error); // Rejeita a promessa de startWebSocketApi
      });

      wsInstance.on('close', (code, reason) => {
        clearTimeout(connectionTimeout);
        console.log(`[WS-API] Conex√£o WebSocket API fechada para conta ${accountId}. Code: ${code}, Reason: ${reason ? reason.toString() : 'N/A'}`);
        cleanupWebSocketApi(accountId);
        // Se a promessa ainda estiver pendente (ex: erro antes de 'open'), rejeitar.
        // No entanto, 'error' ou o timeout j√° deveriam ter cuidado disso.
        // Se 'open' j√° resolveu, este √© apenas um evento informativo.
      });
    });

  } catch (error) {
    console.error(`[WS-API] Erro GERAL ao iniciar WebSocket API para conta ${accountId}:`, error.message);
    cleanupWebSocketApi(accountId);
    return false; // Retorna false em caso de erro geral na inicializa√ß√£o
  }
}

/**
 * Processa mensagens recebidas via WebSocket API
 * @param {Object} message - Mensagem recebida
 * @param {number} accountId - ID da conta
 */
function handleWebSocketApiMessage(message, accountId) {
    try {
        const accountState = getAccountConnectionState(accountId);
        if (!accountState) {
            console.error(`[WS-API] Estado da conta ${accountId} n√£o encontrado para processar mensagem`);
            return;
        }
        
        if (message.id) {
            const callbackEntry = accountState.requestCallbacks.get(message.id);
            
            if (callbackEntry) {
                // Se callbackEntry for uma fun√ß√£o (caso de authenticateWebSocketApi)
                if (typeof callbackEntry === 'function') {
                    callbackEntry(message); // Chama a fun√ß√£o callback (responseMessage) => {...}
                } 
                // Se callbackEntry for um objeto { resolve, reject, timer } (caso de sendWebSocketApiRequest)
                else if (typeof callbackEntry === 'object' && callbackEntry.resolve && callbackEntry.reject && callbackEntry.timer) {
                    clearTimeout(callbackEntry.timer);
                    if (message.error) {
                        // console.warn(`[WS-API] Erro na resposta para ID ${message.id} (Conta: ${accountId}):`, message.error);
                        callbackEntry.reject(message);
                    } else {
                        callbackEntry.resolve(message);
                    }
                } else {
                    console.warn(`[WS-API] Formato de callback inesperado para ID ${message.id} na conta ${accountId}. Callback:`, callbackEntry);
                }
                accountState.requestCallbacks.delete(message.id); // Remover callback ap√≥s processamento
            } else {
                // N√£o √© necessariamente um aviso se for um evento n√£o solicitado com ID, mas raro.
                // console.warn(`[WS-API] Callback n√£o encontrado para ID ${message.id} na conta ${accountId}. Mensagem:`, JSON.stringify(message));
            }
        } else if (message.method === 'ping') {
            // Responder ao ping do servidor
            console.log(`[WS-API] Ping recebido do servidor para conta ${accountId} (ID: ${message.id || 'N/A'}), enviando pong...`);
            // A Binance espera que o ID do ping seja ecoado no pong.
            sendPong(message.id, accountId); 
        } else if (message.method === 'pong') {
            // Pong recebido do servidor (provavelmente em resposta ao nosso ping de cliente)
            console.log(`[WS-API] Pong recebido do servidor para conta ${accountId} (ID: ${message.id || 'N/A'})`);
            accountState.lastPongTime = Date.now(); // Atualizar o tempo do √∫ltimo pong recebido DO SERVIDOR
        } else if (message.e) { // Assumindo que 'e' indica um evento de stream (ex: order_update)
            // console.log(`[WS-API] Evento recebido para conta ${accountId}: ${message.e}`);
            if (accountState.handlers && accountState.handlers.handleOrderUpdate && message.e === 'ORDER_TRADE_UPDATE') {
                accountState.handlers.handleOrderUpdate(message, accountState.dbInstance, accountId);
            } else if (accountState.handlers && accountState.handlers.handleAccountUpdate && message.e === 'ACCOUNT_UPDATE') {
                 accountState.handlers.handleAccountUpdate(message, accountState.dbInstance, accountId);
            }
            // Adicionar mais handlers de eventos conforme necess√°rio
        } else {
            console.log(`[WS-API] Mensagem n√£o tratada recebida para conta ${accountId}:`, JSON.stringify(message));
        }
        
    } catch (error) {
        console.error(`[WS-API] Erro ao processar mensagem para conta ${accountId}:`, error.message, error.stack);
        console.error('[WS-API] Mensagem original:', JSON.stringify(message, null, 2));
    }
}

/**
 * Limpa recursos do WebSocket API para uma conta espec√≠fica
 * @param {number} accountId - ID da conta
 */
function cleanupWebSocketApi(accountId) {
  const accountState = getAccountConnectionState(accountId);
  if (!accountState) return;

  if (accountState.pingInterval) {
    clearInterval(accountState.pingInterval);
    accountState.pingInterval = null;
  }

  const wsConn = accountState.wsApiConnection; // Pegar refer√™ncia
  if (wsConn) {
    // Remover todos os listeners para evitar chamadas em um objeto que est√° sendo limpo
    wsConn.removeAllListeners('open');
    wsConn.removeAllListeners('message');
    wsConn.removeAllListeners('error');
    wsConn.removeAllListeners('close');
    wsConn.removeAllListeners('ping');
    wsConn.removeAllListeners('pong');

    if (typeof wsConn.terminate === 'function' && 
        (wsConn.readyState === WebSocket.OPEN || wsConn.readyState === WebSocket.CONNECTING)) {
      try {
        // console.log(`[WS-API] Terminando wsApiConnection para conta ${accountId}. Estado: ${wsConn.readyState}`);
        wsConn.terminate();
      } catch (e) {
        console.warn(`[WS-API] Erro menor ao terminar wsApiConnection para conta ${accountId}: ${e.message}`);
      }
    }
  }
  accountState.wsApiConnection = null;
  accountState.wsApiAuthenticated = false;
  
  if (accountState.requestCallbacks) {
    for (const [id, callbackEntry] of accountState.requestCallbacks.entries()) {
      if (callbackEntry && callbackEntry.timer) clearTimeout(callbackEntry.timer);
      if (callbackEntry && typeof callbackEntry.reject === 'function') {
        // N√£o logar erro aqui, apenas rejeitar a promessa se existir
        callbackEntry.reject({ error: 'WebSocket connection closed or cleaned up', id });
      } else if (typeof callbackEntry === 'function') {
        // Para o callback de autentica√ß√£o, n√£o h√° reject expl√≠cito aqui,
        // o timeout ou erro de conex√£o j√° teria tratado.
      }
    }
    accountState.requestCallbacks.clear();
  }
  // console.log(`[WS-API] Estado da WebSocket API limpo para conta ${accountId}`);
}

/**
 * Envia pong em resposta a ping do servidor ou como keep-alive.
 * @param {string | undefined} pingId - ID da mensagem de ping original, para ecoar. Se undefined, um novo ID pode ser gerado.
 * @param {number} accountId - ID da conta
 */
function sendPong(pingId, accountId) {
  const accountState = getAccountConnectionState(accountId);
  if (!accountState || !accountState.wsApiConnection || accountState.wsApiConnection.readyState !== WebSocket.OPEN) {
    // console.warn(`[WS-API] N√£o √© poss√≠vel enviar pong para conta ${accountId}, conex√£o n√£o est√° aberta ou estado n√£o encontrado.`);
    return;
  }
  
  try {
    const pongRequest = {
      method: 'pong'
    };
    // Se um pingId foi fornecido (resposta a um ping do servidor), use-o.
    // Caso contr√°rio (ping proativo do cliente), o ID √© opcional ou pode ser gerado.
    // A documenta√ß√£o da Binance sugere ecoar o ID do ping.
    if (pingId) {
      pongRequest.id = pingId;
    }
    // Se n√£o h√° pingId, a Binance aceita pong sem ID ou com um ID arbitr√°rio.
    // Ex: {"method": "pong"} ou {"id": "client-pong-123", "method": "pong"}

    // console.log(`[WS-API] Enviando pong para conta ${accountId}:`, JSON.stringify(pongRequest));
    accountState.wsApiConnection.send(JSON.stringify(pongRequest));
  } catch (error) {
    console.error(`[WS-API] Erro ao enviar pong para conta ${accountId}:`, error);
  }
}

/**
 * Verifica o status da sess√£o da WebSocket API
 * @param {number} accountId - ID da conta
 * @returns {Promise<Object>} - Status da sess√£o
 */
async function checkSessionStatus(accountId) {
  try {
    // Criar a requisi√ß√£o usando createSignedRequest, que lida com o ID e n√£o assina 'session.status'
    const request = await createSignedRequest('session.status', {}, accountId);
    const response = await sendWebSocketApiRequest(request, 30000, accountId); // Passar o objeto request completo
    
    const accountState = getAccountConnectionState(accountId, true); // Garante que o estado existe
    
    if (response && response.result) {
      // Atualiza o estado de autentica√ß√£o baseado na resposta
      accountState.wsApiAuthenticated = response.result.apiKey !== null && response.result.authorizedSince > 0;
    } else {
      // Se n√£o houver resultado ou houver erro na resposta, considerar n√£o autenticado
      accountState.wsApiAuthenticated = false;
    }
    
    return response; // Retorna a resposta completa
  } catch (error) {
    console.error(`[WS-API] Erro ao verificar status da sess√£o para conta ${accountId}:`, error.message || error);
    const accountState = getAccountConnectionState(accountId, true);
    accountState.wsApiAuthenticated = false; // Considerar n√£o autenticado em caso de erro
    return { result: { apiKey: null, authorizedSince: 0, connectedSince: 0 }, error: { message: error.message || 'Erro desconhecido ao verificar status', code: error.code || -1 } };
  }
}

/**
 * Autentica na WebSocket API usando session.logon conforme documenta√ß√£o Binance
 * @param {WebSocket} ws - Conex√£o WebSocket
 * @param {number} accountId - ID da conta
 * @returns {Promise<boolean>} - true se autentica√ß√£o bem-sucedida
 */
async function authenticateWebSocketApi(ws, accountId) {
  try {
    const accountState = getAccountConnectionState(accountId);
    if (!accountState || !accountState.wsApiKey || !accountState.privateKey) { // privateKey aqui √© a PEM
      throw new Error(`Credenciais WebSocket (apiKey ou privateKey PEM) incompletas para conta ${accountId}`);
    }

    console.log(`[WS-API] Iniciando autentica√ß√£o session.logon para conta ${accountId}...`);

    const timestamp = Date.now();
    const authParams = {
      apiKey: accountState.wsApiKey,
      timestamp: timestamp
    };
    const sortedKeys = Object.keys(authParams).sort();
    const payload = sortedKeys.map(key => `${key}=${authParams[key]}`).join('&');
    const signature = await createEd25519Signature(payload, accountId);

    const authRequest = {
      id: `auth-${timestamp}-${accountId}`,
      method: 'session.logon',
      params: {
        apiKey: authParams.apiKey,
        signature: signature,
        timestamp: authParams.timestamp
      }
    };

    return new Promise((resolve, reject) => {
      const timeoutDuration = 30000;
      const timeoutId = setTimeout(() => {
        // accountState.requestCallbacks.delete(authRequest.id); // Removido daqui, ser√° deletado no handler
        console.error(`[WS-API] Timeout na autentica√ß√£o WebSocket API para conta ${accountId} (ID: ${authRequest.id})`);
        reject(new Error(`Timeout na autentica√ß√£o WebSocket API (ID: ${authRequest.id})`));
      }, timeoutDuration);

      // CORRE√á√ÉO: Usar .set() para o Map e armazenar a fun√ß√£o de callback diretamente
      // O handler de mensagens vai chamar esta fun√ß√£o diretamente.
      accountState.requestCallbacks.set(authRequest.id, (responseMessage) => {
        clearTimeout(timeoutId); // Limpar o timeout espec√≠fico desta autentica√ß√£o
        // O callback j√° foi removido do Map pelo handleWebSocketApiMessage
        
        console.log(`[WS-API] Resposta recebida para autentica√ß√£o (ID: ${authRequest.id}):`, JSON.stringify(responseMessage, null, 2));
        
        if (responseMessage.status === 200 && responseMessage.result) {
          console.log(`[WS-API] ‚úÖ Autentica√ß√£o session.logon bem-sucedida para conta ${accountId}`);
          accountState.wsApiAuthenticated = true;
          accountState.isAuthenticated = true;
          resolve(true);
        } else {
          const errorMsg = responseMessage.error?.msg || 'Erro desconhecido na autentica√ß√£o';
          console.error(`[WS-API] Falha na autentica√ß√£o session.logon para conta ${accountId}:`, errorMsg, responseMessage.error);
          reject(new Error(`Falha na autentica√ß√£o session.logon: ${errorMsg} (Code: ${responseMessage.error?.code})`));
        }
      });

      console.log(`[WS-API] Enviando requisi√ß√£o de autentica√ß√£o (ID: ${authRequest.id}):`, JSON.stringify(authRequest, null, 2));
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(authRequest));
      } else {
        clearTimeout(timeoutId);
        accountState.requestCallbacks.delete(authRequest.id); // Remover se n√£o p√¥de enviar
        console.error(`[WS-API] WebSocket n√£o est√° aberto ao tentar enviar autentica√ß√£o para conta ${accountId}. Estado: ${ws.readyState}`);
        reject(new Error('WebSocket n√£o est√° aberto para autentica√ß√£o.'));
      }
    });

  } catch (error) {
    console.error(`[WS-API] Erro cr√≠tico na fun√ß√£o authenticateWebSocketApi para conta ${accountId}:`, error.message);
    throw error;
  }
}

/**
 * Envia uma requisi√ß√£o via WebSocket API
 * @param {Object} request - Objeto de requisi√ß√£o, idealmente j√° processado por createSignedRequest se necessitar assinatura.
 * @param {number} timeout - Tempo limite em ms
 * @param {number} accountId - ID da conta
 * @returns {Promise<Object>} - Resposta da API
 */
async function sendWebSocketApiRequest(request, timeout = 30000, accountId) {
  const accountState = getAccountConnectionState(accountId);

  if (!accountState) {
    // Tentar carregar credenciais e estado se n√£o existir
    try {
      await api.loadCredentialsFromDatabase(accountId);
      // Ap√≥s carregar, accountState deve existir
      const newState = getAccountConnectionState(accountId);
      if (!newState) {
        return Promise.reject(new Error(`[WS-API] Estado da conta ${accountId} n√£o p√¥de ser inicializado.`));
      }
      // Continuar com newState, mas a l√≥gica abaixo j√° pega o accountState atualizado
    } catch (loadErr) {
      return Promise.reject(new Error(`[WS-API] Falha ao carregar credenciais para conta ${accountId} antes de enviar requisi√ß√£o: ${loadErr.message}`));
    }
  }
  
  // Re-obter accountState caso tenha sido criado/atualizado acima
  const currentAccountState = getAccountConnectionState(accountId);
  if (!currentAccountState) {
      return Promise.reject(new Error(`[WS-API] Estado da conta ${accountId} n√£o encontrado ap√≥s tentativa de carga.`));
  }


  // Verificar conex√£o WebSocket
  if (!currentAccountState.wsApiConnection || currentAccountState.wsApiConnection.readyState !== WebSocket.OPEN) {
    console.log(`[WS-API] Conex√£o WebSocket API n√£o est√° aberta para conta ${accountId}. Tentando estabelecer...`);
    try {
      const connected = await startWebSocketApi(accountId); // startWebSocketApi j√° atualiza currentAccountState.wsApiConnection
      if (!connected || !currentAccountState.wsApiConnection || currentAccountState.wsApiConnection.readyState !== WebSocket.OPEN) {
        throw new Error('Falha ao estabelecer conex√£o WebSocket API.');
      }
      // Pequena pausa para garantir estabilidade ap√≥s abertura, se necess√°rio
      // await new Promise(resolve => setTimeout(resolve, 200));
      console.log(`[WS-API] Conex√£o WebSocket API restabelecida para conta ${accountId}.`);
    } catch (connError) {
      console.error(`[WS-API] Erro ao tentar (re)estabelecer conex√£o WebSocket API para conta ${accountId}: ${connError.message}`);
      return Promise.reject(new Error(`[WS-API] WebSocket API n√£o conectado para conta ${accountId}: ${connError.message}`));
    }
  }

  // Garantir que temos um ID para a requisi√ß√£o.
  // Se a requisi√ß√£o veio de createSignedRequest, ela j√° ter√° um ID.
  const requestId = request.id || uuidv4();
  request.id = requestId; // Assegura que o objeto request tenha o ID que ser√° usado no callback

  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      if (currentAccountState.requestCallbacks.has(requestId)) {
        currentAccountState.requestCallbacks.delete(requestId);
        console.error(`[WS-API] Timeout para requisi√ß√£o ID ${requestId} (Conta: ${accountId}, M√©todo: ${request.method})`);
        reject({ error: `Timeout para requisi√ß√£o ${requestId}`, id: requestId, method: request.method });
      }
    }, timeout);

    currentAccountState.requestCallbacks.set(requestId, { resolve, reject, timer });

    try {
      const requestString = JSON.stringify(request);
      // console.log(`[WS-API] Enviando para conta ${accountId} (ID: ${requestId}): ${requestString}`); // Log verboso
      if (currentAccountState.wsApiConnection.readyState === WebSocket.OPEN) {
        currentAccountState.wsApiConnection.send(requestString);
      } else {
        // Limpar callback e timer se a conex√£o fechou antes do send
        clearTimeout(timer);
        currentAccountState.requestCallbacks.delete(requestId);
        console.error(`[WS-API] Conex√£o fechou antes de enviar req ID ${requestId} (Conta: ${accountId})`);
        reject(new Error(`WebSocket API connection closed before sending request ${requestId} for account ${accountId}.`));
      }
    } catch (error) {
      clearTimeout(timer);
      currentAccountState.requestCallbacks.delete(requestId);
      console.error(`[WS-API] Erro ao enviar requisi√ß√£o ID ${requestId} (Conta: ${accountId}):`, error);
      reject({ error: `Erro ao enviar requisi√ß√£o: ${error.message}`, id: requestId, method: request.method });
    }
  });
}

/**
 * Cria um buffer DER para chave privada Ed25519 a partir de chave raw
 * @param {Buffer} rawKey - Chave privada raw de 32 bytes
 * @returns {Buffer} - Chave no formato DER
 */
function createEd25519DERFromRaw(rawKey) {
    // Ed25519 private key DER structure:
    // SEQUENCE {
    //   INTEGER 0
    //   SEQUENCE {
    //     OBJECT IDENTIFIER 1.3.101.112 (Ed25519)
    //   }
    //   OCTET STRING {
    //     OCTET STRING (32-byte private key)
    //   }
    // }
    
    const ed25519OID = Buffer.from('302a300506032b657004200420', 'hex');
    const derKey = Buffer.concat([ed25519OID, rawKey]);
    
    return derKey;
}

/**
 * Limpa completamente todas as conex√µes para uma conta
 * @param {number} accountId - ID da conta
 */
function forceCleanupAccount(accountId) {
  console.log(`[WEBSOCKET] üßπ Limpeza completa para conta ${accountId}...`);
  
  try {
    // Limpar WebSocket API
    cleanupWebSocketApi(accountId);
    
    // Limpar WebSockets de pre√ßo
    const priceWebsockets = getPriceWebsockets(accountId);
    if (priceWebsockets) {
      for (const [symbol, ws] of priceWebsockets.entries()) {
        if (ws && ws.readyState !== WebSocket.CLOSED) {
          ws.close(1000, 'Graceful shutdown');
        }
      }
      priceWebsockets.clear();
    }
    
    // Limpar userDataWebSocket
    const accountState = getAccountConnectionState(accountId);
    if (accountState) {
      if (accountState.userDataWebSocket && accountState.userDataWebSocket.readyState !== WebSocket.CLOSED) {
        accountState.userDataWebSocket.close(1000, 'Graceful shutdown');
      }
      
      // Limpar keepalive do listenKey
      if (accountState.listenKeyKeepAliveInterval) {
        clearInterval(accountState.listenKeyKeepAliveInterval);
        accountState.listenKeyKeepAliveInterval = null;
      }
      
      // Remover estado da conta
      accountConnections.delete(accountId);
    }
    
    console.log(`[WEBSOCKETS] ‚úÖ Limpeza completa conclu√≠da para conta ${accountId}`);
    
  } catch (error) {
    console.error(`[WEBSOCKETS] ‚ùå Erro durante limpeza da conta ${accountId}:`, error.message);
  }
}

// Atualizar fun√ß√£o reset para usar o novo cleanup
function reset(accountId) {
  forceCleanupAccount(accountId);
}

module.exports = {
  startUserDataStream,
  setupBookDepthWebsocket,
  ensurePriceWebsocketExists,
  stopPriceMonitoring,
  reset, // reset agora chama forceCleanupAccount
  startWebSocketApi,
  authenticateWebSocketApi,
  sendWebSocketApiRequest,
  createSignedRequest, // Exportar esta fun√ß√£o async
  checkSessionStatus,
  cleanupWebSocketApi,
  isWebSocketApiAuthenticated,
  isWebSocketApiConnected,
  // loadCredentialsFromDatabase, // REMOVIDO - usar api.loadCredentialsFromDatabase
  setMonitoringCallbacks,
  getHandlers,
  getCredentials,
  ensureWebSocketApiExists,
  getAllAccountConnections, // Revisar o que esta fun√ß√£o deve retornar
  handleWebSocketApiMessage,
  createEd25519Signature, // Exportar esta fun√ß√£o async
  createEd25519DERFromRaw,
  forceCleanupAccount,
  loadNobleEd25519, // Exportar se precisar ser chamado externamente
};