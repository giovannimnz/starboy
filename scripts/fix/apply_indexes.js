const mysql = require('mysql2/promise');
const fs = require('fs');
const path = require('path');

// Carrega as vari√°veis de ambiente
require('dotenv').config({ path: path.resolve(__dirname, 'config/.env') });

/**
 * Script para aplicar √≠ndices de otimiza√ß√£o no banco de dados
 * Baseado na an√°lise das consultas mais cr√≠ticas do sistema
 */
async function applyDatabaseIndexes() {
    console.log('=========================================================================');
    console.log('üöÄ APLICA√á√ÉO DE √çNDICES DE OTIMIZA√á√ÉO - STARBOY TRADING SYSTEM');
    console.log('=========================================================================');
    console.log(`‚è∞ Iniciado em: ${new Date().toLocaleString()}\n`);

    let connection;

    try {
        // Verificar argumentos da linha de comando
        const args = process.argv.slice(2);
        const isAnalyzeMode = args.includes('--analyze');
        const isMonitorMode = args.includes('--monitor');

        if (isAnalyzeMode) {
            await analyzeIndexPerformance();
            return;
        }

        if (isMonitorMode) {
            await monitorIndexUsage();
            return;
        }

        // Conectar ao banco
        console.log('üîó Conectando ao banco de dados...');
        console.log(`   Host: ${process.env.DB_HOST}`);
        console.log(`   Porta: ${process.env.DB_PORT}`);
        console.log(`   Banco: ${process.env.DB_NAME}`);
        console.log(`   Usu√°rio: ${process.env.DB_USER}\n`);

        connection = await mysql.createConnection({
            host: process.env.DB_HOST,
            port: process.env.DB_PORT,
            user: process.env.DB_USER,
            password: process.env.DB_PASSWORD,
            database: process.env.DB_NAME,
            multipleStatements: true
        });

        console.log('‚úÖ Conex√£o estabelecida com sucesso!\n');

        // Fazer backup da estrutura antes de aplicar
        console.log('üíæ Criando backup da estrutura...');
        await createStructureBackup(connection);

        // Ler o arquivo de √≠ndices
        const sqlFile = path.join(__dirname, 'backend/core/database/migrations/database_indexes_optimization.sql');
        
        if (!fs.existsSync(sqlFile)) {
            throw new Error('Arquivo de √≠ndices n√£o encontrado: ' + sqlFile);
        }

        console.log('üìÑ Lendo arquivo de √≠ndices...');
        const sqlContent = fs.readFileSync(sqlFile, 'utf8');

        // Aplicar o arquivo SQL completo
        console.log('üîß Aplicando √≠ndices de otimiza√ß√£o...');
        await connection.query(sqlContent);

        console.log('‚úÖ √çndices aplicados com sucesso!\n');

        // Verificar √≠ndices criados
        await verifyIndexes(connection);

        // Executar an√°lise das tabelas
        await analyzeMainTables(connection);

        // Testar queries cr√≠ticas
        await testCriticalQueries(connection);

        console.log('=========================================================================');
        console.log('‚úÖ APLICA√á√ÉO DE √çNDICES CONCLU√çDA COM SUCESSO!');
        console.log('=========================================================================');
        console.log(`‚è∞ Finalizado em: ${new Date().toLocaleString()}\n`);

        console.log('üìã PR√ìXIMOS PASSOS:');
        console.log('   1. üîÑ Reinicie o sistema para garantir uso dos novos √≠ndices');
        console.log('   2. üìä Monitore performance com: node apply_indexes.js --monitor');
        console.log('   3. üß™ Execute testes das funcionalidades principais');
        console.log('   4. üíæ Verifique uso de espa√ßo em disco regularmente\n');

    } catch (error) {
        console.error('‚ùå Erro durante a aplica√ß√£o dos √≠ndices:', error);
        throw error;
    } finally {
        if (connection) {
            await connection.end();
            console.log('üîå Conex√£o fechada.\n');
        }
    }
}

/**
 * Cria backup da estrutura da base de dados
 */
async function createStructureBackup(connection) {
    try {
        const backupDir = path.join(__dirname, 'backend/core/backups');
        if (!fs.existsSync(backupDir)) {
            fs.mkdirSync(backupDir, { recursive: true });
        }
        
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const backupFile = path.join(backupDir, `indexes_backup_${timestamp}.sql`);
        
        console.log(`   Backup seria salvo em: ${backupFile}`);
        console.log('‚úÖ Use mysqldump para backup completo da estrutura\n');
        
    } catch (error) {
        console.warn('‚ö†Ô∏è  Aviso: N√£o foi poss√≠vel criar backup via Node.js');
        console.warn('   Recomenda-se usar mysqldump diretamente\n');
    }
}

/**
 * Verifica os √≠ndices criados
 */
async function verifyIndexes(connection) {
    console.log('üìä Verificando √≠ndices aplicados...');
    
    const [indexes] = await connection.query(`
        SELECT 
            TABLE_NAME as tabela,
            COUNT(*) as total_indices
        FROM information_schema.STATISTICS 
        WHERE TABLE_SCHEMA = DATABASE() 
            AND TABLE_NAME IN ('posicoes', 'ordens', 'webhook_signals', 'contas')
            AND INDEX_NAME LIKE 'idx_%'
        GROUP BY TABLE_NAME
        ORDER BY TABLE_NAME
    `);
    
    console.log('\n   √çndices por tabela:');
    indexes.forEach(row => {
        console.log(`   ‚Ä¢ ${row.tabela}: ${row.total_indices} √≠ndices`);
    });
    console.log('');
}

/**
 * Executa ANALYZE TABLE nas tabelas principais
 */
async function analyzeMainTables(connection) {
    console.log('üîç Atualizando estat√≠sticas das tabelas...');
    
    const tables = ['posicoes', 'ordens', 'webhook_signals', 'contas'];
    
    for (const table of tables) {
        try {
            await connection.query(`ANALYZE TABLE ${table}`);
            console.log(`   ‚úÖ ${table} analisada`);
        } catch (error) {
            console.log(`   ‚ö†Ô∏è  Erro ao analisar ${table}: ${error.message}`);
        }
    }
    console.log('');
}

/**
 * Testa as queries mais cr√≠ticas do sistema
 */
async function testCriticalQueries(connection) {
    console.log('üß™ Testando queries cr√≠ticas...');
    
    try {
        // Teste 1: Query cr√≠tica do reverse.js (linha 983)
        console.log('   ‚Ä¢ Testando: posi√ß√µes por s√≠mbolo + status + conta...');
        const [explain1] = await connection.query(`
            EXPLAIN SELECT id FROM posicoes 
            WHERE simbolo = 'BTCUSDT' AND status = 'OPEN' AND conta_id = 1 
            ORDER BY id DESC LIMIT 1
        `);
        
        const usingIndex1 = explain1.some(row => 
            row.key && row.key.includes('idx_') || 
            row.Extra && row.Extra.includes('Using index')
        );
        console.log(`     ${usingIndex1 ? '‚úÖ' : '‚ö†Ô∏è'} Index ${usingIndex1 ? 'sendo utilizado' : 'pode n√£o estar sendo utilizado'}`);
        
        // Teste 2: Query cr√≠tica do positionSync.js (LEFT JOIN)
        console.log('   ‚Ä¢ Testando: LEFT JOIN posi√ß√µes sem sinais...');
        const [explain2] = await connection.query(`
            EXPLAIN SELECT p.id FROM posicoes p 
            LEFT JOIN webhook_signals ws ON ws.position_id = p.id 
            WHERE p.status = 'OPEN' AND p.conta_id = 1 AND ws.position_id IS NULL 
            LIMIT 1
        `);
        
        const usingIndex2 = explain2.some(row => 
            row.key && row.key.includes('idx_') || 
            row.Extra && row.Extra.includes('Using index')
        );
        console.log(`     ${usingIndex2 ? '‚úÖ' : '‚ö†Ô∏è'} Index ${usingIndex2 ? 'sendo utilizado' : 'pode n√£o estar sendo utilizado'}`);
        
        // Teste 3: Query de ordens por origin signal
        console.log('   ‚Ä¢ Testando: ordens por origin signal...');
        const [explain3] = await connection.query(`
            EXPLAIN SELECT id_externo FROM ordens 
            WHERE orign_sig = 'test_signal' AND status IN ('NEW', 'PARTIALLY_FILLED') AND conta_id = 1
        `);
        
        const usingIndex3 = explain3.some(row => 
            row.key && row.key.includes('idx_') || 
            row.Extra && row.Extra.includes('Using index')
        );
        console.log(`     ${usingIndex3 ? '‚úÖ' : '‚ö†Ô∏è'} Index ${usingIndex3 ? 'sendo utilizado' : 'pode n√£o estar sendo utilizado'}`);
        
    } catch (error) {
        console.log('   ‚ö†Ô∏è  Erro ao testar queries:', error.message);
    }
    console.log('');
}

/**
 * Fun√ß√£o para an√°lise de performance (modo --analyze)
 */
async function analyzeIndexPerformance() {
    console.log('=========================================================================');
    console.log('üìä AN√ÅLISE DE PERFORMANCE DOS √çNDICES');
    console.log('=========================================================================\n');

    let connection;
    try {
        connection = await mysql.createConnection({
            host: process.env.DB_HOST,
            port: process.env.DB_PORT,
            user: process.env.DB_USER,
            password: process.env.DB_PASSWORD,
            database: process.env.DB_NAME
        });

        console.log('üîó Conectado ao banco de dados\n');

        // An√°lise de tamanhos de tabelas e √≠ndices
        console.log('üìà Tamanhos das tabelas e √≠ndices:');
        const [sizes] = await connection.query(`
            SELECT 
                TABLE_NAME as Tabela,
                TABLE_ROWS as Linhas,
                ROUND(((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024), 2) AS 'Tamanho_Total_MB',
                ROUND((INDEX_LENGTH / 1024 / 1024), 2) AS 'Tamanho_Indices_MB',
                ROUND((INDEX_LENGTH / (DATA_LENGTH + INDEX_LENGTH)) * 100, 1) AS 'Percentual_Indices'
            FROM information_schema.TABLES 
            WHERE TABLE_SCHEMA = DATABASE() 
                AND TABLE_NAME IN ('posicoes', 'ordens', 'webhook_signals', 'contas')
            ORDER BY (DATA_LENGTH + INDEX_LENGTH) DESC
        `);
        
        console.table(sizes);

        // Lista todos os √≠ndices criados
        console.log('\nüìã √çndices criados pelo sistema:');
        const [allIndexes] = await connection.query(`
            SELECT 
                TABLE_NAME as Tabela,
                INDEX_NAME as Indice,
                GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) as Colunas,
                CARDINALITY as Cardinalidade
            FROM information_schema.STATISTICS 
            WHERE TABLE_SCHEMA = DATABASE() 
                AND INDEX_NAME LIKE 'idx_%'
                AND TABLE_NAME IN ('posicoes', 'ordens', 'webhook_signals', 'contas')
            GROUP BY TABLE_NAME, INDEX_NAME
            ORDER BY TABLE_NAME, INDEX_NAME
        `);
        
        console.table(allIndexes);

        // Queries de exemplo para testar performance
        console.log('\nüß™ Queries de teste recomendadas:');
        console.log('');
        console.log('-- Query cr√≠tica 1 (reverse.js):');
        console.log("EXPLAIN SELECT id FROM posicoes WHERE simbolo = 'BTCUSDT' AND status = 'OPEN' AND conta_id = 1 ORDER BY id DESC LIMIT 1;");
        console.log('');
        console.log('-- Query cr√≠tica 2 (positionSync.js):');
        console.log("EXPLAIN SELECT p.id FROM posicoes p LEFT JOIN webhook_signals ws ON ws.position_id = p.id WHERE p.status = 'OPEN' AND p.conta_id = 1 AND ws.position_id IS NULL;");
        console.log('');
        console.log('-- Query cr√≠tica 3 (reverse.js ordens):');
        console.log("EXPLAIN SELECT id_externo FROM ordens WHERE orign_sig = 'signal_123' AND status IN ('NEW', 'PARTIALLY_FILLED') AND conta_id = 1;");

    } catch (error) {
        console.error('‚ùå Erro na an√°lise:', error);
    } finally {
        if (connection) {
            await connection.end();
        }
    }
}

/**
 * Fun√ß√£o para monitoramento de uso dos √≠ndices (modo --monitor)
 */
async function monitorIndexUsage() {
    console.log('=========================================================================');
    console.log('üì° MONITORAMENTO DE USO DOS √çNDICES');
    console.log('=========================================================================\n');

    let connection;
    try {
        connection = await mysql.createConnection({
            host: process.env.DB_HOST,
            port: process.env.DB_PORT,
            user: process.env.DB_USER,
            password: process.env.DB_PASSWORD,
            database: process.env.DB_NAME
        });

        console.log('üîó Conectado ao banco de dados\n');

        // Verificar queries lentas
        console.log('üêå Queries atualmente em execu√ß√£o (> 1 segundo):');
        const [slowQueries] = await connection.query(`
            SELECT 
                ID,
                USER,
                HOST,
                DB,
                COMMAND,
                TIME,
                STATE,
                LEFT(INFO, 100) as QUERY_PREVIEW
            FROM information_schema.PROCESSLIST 
            WHERE COMMAND != 'Sleep' AND TIME > 1
            ORDER BY TIME DESC
        `);
        
        if (slowQueries.length > 0) {
            console.table(slowQueries);
        } else {
            console.log('‚úÖ Nenhuma query lenta detectada no momento\n');
        }

        // Status das tabelas principais
        console.log('üìä Status das tabelas principais:');
        const [tableStatus] = await connection.query(`
            SHOW TABLE STATUS WHERE Name IN ('posicoes', 'ordens', 'webhook_signals', 'contas')
        `);
        
        const relevantStatus = tableStatus.map(table => ({
            Tabela: table.Name,
            Linhas: table.Rows,
            'Tamanho_MB': Math.round((table.Data_length + table.Index_length) / 1024 / 1024 * 100) / 100,
            'Fragmentacao': table.Data_free > 0 ? 'Sim' : 'N√£o',
            Engine: table.Engine
        }));
        
        console.table(relevantStatus);

        // Comandos √∫teis para monitoramento cont√≠nuo
        console.log('\nüõ†Ô∏è  Comandos √∫teis para monitoramento:');
        console.log('');
        console.log('-- Ver queries em execu√ß√£o:');
        console.log('SHOW PROCESSLIST;');
        console.log('');
        console.log('-- Verificar uso dos √≠ndices:');
        console.log('SELECT TABLE_NAME, INDEX_NAME, CARDINALITY FROM information_schema.STATISTICS WHERE TABLE_SCHEMA = DATABASE() ORDER BY CARDINALITY DESC;');
        console.log('');
        console.log('-- Otimizar tabelas (execute durante manuten√ß√£o):');
        console.log('OPTIMIZE TABLE posicoes, ordens, webhook_signals, contas;');
        console.log('');
        console.log('-- Atualizar estat√≠sticas (execute semanalmente):');
        console.log('ANALYZE TABLE posicoes, ordens, webhook_signals, contas;');

    } catch (error) {
        console.error('‚ùå Erro no monitoramento:', error);
    } finally {
        if (connection) {
            await connection.end();
        }
    }
}

// Executar o script
if (require.main === module) {
    applyDatabaseIndexes()
        .then(() => {
            console.log('üéâ Script finalizado com sucesso!');
            process.exit(0);
        })
        .catch(err => {
            console.error('üí• Falha na execu√ß√£o:', err.message);
            process.exit(1);
        });
}

module.exports = { applyDatabaseIndexes, analyzeIndexPerformance, monitorIndexUsage };
