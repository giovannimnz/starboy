const { getDatabaseInstance, moveClosedPositionsAndOrders } = require('../../../core/database/conexao');
const { getAllOpenPositions, getOpenOrders } = require('../api/rest');

/**
 * Sincroniza posi√ß√µes do banco com a corretora
 * @param {number} accountId - ID da conta
 * @returns {Promise<Object>} - Resultado da sincroniza√ß√£o
 */
async function syncPositionsWithExchange(accountId) {
  try {
    // CORRE√á√ÉO CR√çTICA: Validar accountId
    if (!accountId || typeof accountId !== 'number') {
      throw new Error(`AccountId inv√°lido em syncPositionsWithExchange: ${accountId} (tipo: ${typeof accountId})`);
    }

    console.log(`[SYNC] Iniciando sincroniza√ß√£o de posi√ß√µes para conta ${accountId}...`);
    
    const db = await getDatabaseInstance();
    if (!db) {
      throw new Error(`Falha ao conectar ao banco para conta ${accountId}`);
    }

    // CORRE√á√ÉO CR√çTICA: Log de debug antes da chamada
    console.log(`[SYNC] Chamando getAllOpenPositions com accountId: ${accountId} (tipo: ${typeof accountId})`);
    
    // CORRE√á√ÉO CR√çTICA: Chamar getAllOpenPositions apenas com accountId (n√∫mero)
    const exchangePositions = await getAllOpenPositions(accountId);
    
    console.log(`[SYNC] Obtidas ${exchangePositions.length} posi√ß√µes da corretora para conta ${accountId}`);

    // Obter posi√ß√µes do banco de dados
    const [dbPositions] = await db.query(`
      SELECT 
        id, simbolo, quantidade, preco_medio, side, status,
        preco_entrada, preco_corrente, leverage
      FROM posicoes 
      WHERE status = 'OPEN' AND conta_id = ?
      ORDER BY simbolo
    `, [accountId]);

    console.log(`[SYNC] Encontradas ${dbPositions.length} posi√ß√µes no banco para conta ${accountId}`);

    let syncResults = {
      exchangePositions: exchangePositions.length,
      dbPositions: dbPositions.length,
      missingInDb: 0,
      missingInExchange: 0,
      updated: 0,
      errors: []
    };

    // Verificar posi√ß√µes que existem na corretora mas n√£o no banco
    for (const exchangePos of exchangePositions) {
      const dbPos = dbPositions.find(p => p.simbolo === exchangePos.simbolo);
      
      if (!dbPos) {
        console.warn(`[SYNC] Posi√ß√£o ${exchangePos.simbolo} existe na corretora mas n√£o no banco (conta ${accountId})`);
        syncResults.missingInDb++;
        
        // Opcional: Criar posi√ß√£o no banco automaticamente
        try {
          await db.query(`
            INSERT INTO posicoes (
              simbolo, quantidade, preco_medio, side, status, 
              preco_entrada, preco_corrente, leverage, conta_id,
              data_hora_abertura, data_hora_ultima_atualizacao
            ) VALUES (?, ?, ?, ?, 'OPEN', ?, ?, ?, ?, NOW(), NOW())
          `, [
            exchangePos.simbolo,
            parseFloat(exchangePos.quantidade),
            parseFloat(exchangePos.precoEntrada),
            exchangePos.lado,
            parseFloat(exchangePos.precoEntrada),
            parseFloat(exchangePos.precoAtual),
            parseInt(exchangePos.alavancagem || 1),
            accountId
          ]);
          
          console.log(`[SYNC] ‚úÖ Posi√ß√£o ${exchangePos.simbolo} criada no banco para conta ${accountId}`);
          syncResults.updated++;
        } catch (createError) {
          console.error(`[SYNC] Erro ao criar posi√ß√£o ${exchangePos.simbolo} no banco:`, createError.message);
          syncResults.errors.push(`Erro ao criar ${exchangePos.simbolo}: ${createError.message}`);
        }
      } else {
        // Atualizar pre√ßo corrente se a posi√ß√£o j√° existe
        try {
          await db.query(`
            UPDATE posicoes 
            SET preco_corrente = ?, data_hora_ultima_atualizacao = NOW()
            WHERE id = ?
          `, [parseFloat(exchangePos.precoAtual), dbPos.id]);
          
          syncResults.updated++;
        } catch (updateError) {
          console.error(`[SYNC] Erro ao atualizar posi√ß√£o ${dbPos.simbolo}:`, updateError.message);
          syncResults.errors.push(`Erro ao atualizar ${dbPos.simbolo}: ${updateError.message}`);
        }
      }
    }

    // Verificar posi√ß√µes que existem no banco mas n√£o na corretora
    for (const dbPos of dbPositions) {
      const exchangePos = exchangePositions.find(p => p.simbolo === dbPos.simbolo);
      
      if (!exchangePos) {
        console.warn(`[SYNC] Posi√ß√£o ${dbPos.simbolo} existe no banco mas n√£o na corretora (conta ${accountId})`);
        syncResults.missingInExchange++;
        
        // Opcional: Marcar como fechada no banco
        try {
          await db.query(`
            UPDATE posicoes 
            SET status = 'CLOSED', data_hora_fechamento = NOW()
            WHERE id = ?
          `, [dbPos.id]);
          
          console.log(`[SYNC] ‚úÖ Posi√ß√£o ${dbPos.simbolo} marcada como fechada no banco (conta ${accountId})`);
          syncResults.updated++;
        } catch (closeError) {
          console.error(`[SYNC] Erro ao fechar posi√ß√£o ${dbPos.simbolo} no banco:`, closeError.message);
          syncResults.errors.push(`Erro ao fechar ${dbPos.simbolo}: ${closeError.message}`);
        }
      }
    }

    console.log(`[SYNC] ‚úÖ Sincroniza√ß√£o conclu√≠da para conta ${accountId}:`, syncResults);
    return syncResults;

  } catch (error) {
    console.error(`[SYNC] Erro cr√≠tico ao sincronizar posi√ß√µes para conta ${accountId}:`, error);
    throw error;
  }
}

/**
 * Exibe log de posi√ß√µes abertas e ordens pendentes
 * @param {number} accountId - ID da conta
 */
async function logOpenPositionsAndOrdersVisual(accountId) {
  try {
    const db = await getDatabaseInstance();
    if (!db) {
      console.error('[MONITOR] Falha ao obter inst√¢ncia do banco de dados');
      return;
    }

    // Obter posi√ß√µes abertas do banco
    const [dbPositions] = await db.query(`SELECT id, simbolo, quantidade, preco_entrada, preco_corrente, side FROM posicoes WHERE status = 'OPEN'${accountId ? ' AND conta_id = ?' : ''}`, accountId ? [accountId] : []);
    
    // Obter ordens pendentes
    const [pendingOrders] = await db.query(`
      SELECT simbolo, tipo_ordem_bot, tipo_ordem, preco, quantidade, status, side 
      FROM ordens 
      WHERE status IN ('NEW', 'PARTIALLY_FILLED')${accountId ? ' AND conta_id = ?' : ''}
      ORDER BY simbolo, tipo_ordem_bot
    `, accountId ? [accountId] : []);

    // Obter posi√ß√µes abertas da corretora para compara√ß√£o
    const exchangePositions = await getAllOpenPositions(accountId);

    // Barra visual
    const bar = (count, emoji) => count > 0 ? emoji.repeat(Math.min(count, 20)) : '';
    const pad = (str, len) => (str + ' '.repeat(len)).slice(0, len);

    console.log('\n=== üìä VISUALIZA√á√ÉO DE POSI√á√ïES E ORDENS ===');
    console.log(
      `Banco:   |${bar(dbPositions.length, 'üü©')}${pad('', 20 - dbPositions.length)}| ${dbPositions.length} posi√ß√µes`
    );
    console.log(
      `Corretora:|${bar(exchangePositions.length, 'üü¶')}${pad('', 20 - exchangePositions.length)}| ${exchangePositions.length} posi√ß√µes`
    );
    console.log(
      `Ordens:  |${bar(pendingOrders.length, 'üü®')}${pad('', 20 - pendingOrders.length)}| ${pendingOrders.length} pendentes`
    );
    console.log('-------------------------------------------');

    // Mostrar detalhes (opcional)
    if (dbPositions.length > 0) {
      console.log('\nüìä Posi√ß√µes no Banco:');
      dbPositions.forEach(pos => {
        console.log(`  ${pad(pos.simbolo, 8)} | ${pad(pos.side, 4)} | ${pad(pos.quantidade, 8)} @ ${pad(pos.preco_entrada, 10)} | Atual: ${pos.preco_corrente}`);
      });
    }
    if (exchangePositions.length > 0) {
      console.log('\nüè¶ Posi√ß√µes na Corretora:');
      exchangePositions.forEach(pos => {
        console.log(`  ${pad(pos.simbolo, 8)} | ${pad(pos.side, 4)} | ${pad(pos.quantidade, 8)} @ ${pad(pos.preco_entrada, 10)}`);
      });
    }
    if (pendingOrders.length > 0) {
      console.log('\nüìã Ordens Pendentes:');
      pendingOrders.forEach(order => {
        console.log(`  ${pad(order.simbolo, 8)} | ${pad(order.tipo_ordem_bot, 10)} | ${pad(order.side, 4)} | ${pad(order.quantidade, 8)} @ ${pad(order.preco, 10)} (${order.status})`);
      });
    }
    console.log('===========================================\n');
  } catch (error) {
    console.error('[MONITOR] Erro ao obter posi√ß√µes e ordens:', error);
  }
}

/**
 * ‚úÖ SINCRONIZA√á√ÉO AVAN√áADA COM MOVIMENTA√á√ÉO AUTOM√ÅTICA
 * Baseada na vers√£o do _dev
 */
async function syncPositionsWithAutoClose(accountId) {
  try {
    if (!accountId || typeof accountId !== 'number') {
      throw new Error(`AccountId inv√°lido em syncPositionsWithAutoClose: ${accountId}`);
    }

    console.log(`[SYNC_AUTO] üîÑ Iniciando sincroniza√ß√£o avan√ßada para conta ${accountId}...`);
    
    const db = await getDatabaseInstance();
    const { movePositionToHistory } = require('./positionHistory');
    
    // Obter posi√ß√µes do banco e corretora
    const [dbPositions] = await db.query(`
      SELECT id, simbolo, quantidade, side, status, preco_entrada, preco_corrente
      FROM posicoes 
      WHERE status = 'OPEN' AND conta_id = ?
      ORDER BY simbolo
    `, [accountId]);

    const exchangePositions = await getAllOpenPositions(accountId);
    
    console.log(`[SYNC_AUTO] üìä Banco: ${dbPositions.length} posi√ß√µes | Corretora: ${exchangePositions.length} posi√ß√µes`);

    let syncResults = {
      checked: dbPositions.length,
      movedToHistory: 0,
      updatedPrices: 0,
      errors: []
    };

    // Criar mapa de posi√ß√µes da corretora para busca r√°pida
    const exchangeMap = new Map();
    exchangePositions.forEach(pos => {
      exchangeMap.set(pos.simbolo, pos);
    });

    // Verificar cada posi√ß√£o do banco
    for (const dbPos of dbPositions) {
      const exchangePos = exchangeMap.get(dbPos.simbolo);
      
      if (!exchangePos || Math.abs(parseFloat(exchangePos.quantidade)) <= 0.000001) {
        // POSI√á√ÉO N√ÉO EXISTE MAIS NA CORRETORA - MOVER PARA HIST√ìRICO
        console.log(`[SYNC_AUTO] üîÑ Posi√ß√£o ${dbPos.simbolo} fechada na corretora, movendo para hist√≥rico...`);
        
        try {
          const moved = await movePositionToHistory(
            db, 
            dbPos.id, 
            'CLOSED', 
            'Sincroniza√ß√£o autom√°tica - posi√ß√£o n√£o encontrada na corretora',
            accountId
          );
          
          if (moved) {
            syncResults.movedToHistory++;
            console.log(`[SYNC_AUTO] ‚úÖ Posi√ß√£o ${dbPos.simbolo} movida para hist√≥rico`);
          } else {
            syncResults.errors.push(`Falha ao mover ${dbPos.simbolo} para hist√≥rico`);
          }
          
        } catch (moveError) {
          console.error(`[SYNC_AUTO] ‚ùå Erro ao mover ${dbPos.simbolo}:`, moveError.message);
          syncResults.errors.push(`Erro ao mover ${dbPos.simbolo}: ${moveError.message}`);
        }
        
      } else {
        // POSI√á√ÉO EXISTE - ATUALIZAR PRE√áO CORRENTE SE NECESS√ÅRIO
        const currentExchangePrice = parseFloat(exchangePos.precoAtual);
        const dbCurrentPrice = parseFloat(dbPos.preco_corrente || 0);
        
        if (Math.abs(currentExchangePrice - dbCurrentPrice) > 0.001) {
          try {
            await db.query(`
              UPDATE posicoes 
              SET preco_corrente = ?, data_hora_ultima_atualizacao = NOW()
              WHERE id = ?
            `, [currentExchangePrice, dbPos.id]);
            
            syncResults.updatedPrices++;
            console.log(`[SYNC_AUTO] üìä Pre√ßo atualizado para ${dbPos.simbolo}: ${dbCurrentPrice} ‚Üí ${currentExchangePrice}`);
            
          } catch (updateError) {
            console.error(`[SYNC_AUTO] ‚ùå Erro ao atualizar pre√ßo ${dbPos.simbolo}:`, updateError.message);
            syncResults.errors.push(`Erro ao atualizar pre√ßo ${dbPos.simbolo}: ${updateError.message}`);
          }
        }
      }
    }

    console.log(`[SYNC_AUTO] ‚úÖ Sincroniza√ß√£o avan√ßada conclu√≠da para conta ${accountId}:`);
    console.log(`[SYNC_AUTO]   - Posi√ß√µes verificadas: ${syncResults.checked}`);
    console.log(`[SYNC_AUTO]   - Movidas para hist√≥rico: ${syncResults.movedToHistory}`);
    console.log(`[SYNC_AUTO]   - Pre√ßos atualizados: ${syncResults.updatedPrices}`);
    console.log(`[SYNC_AUTO]   - Erros: ${syncResults.errors.length}`);

    return syncResults;

  } catch (error) {
    console.error(`[SYNC_AUTO] ‚ùå Erro cr√≠tico na sincroniza√ß√£o avan√ßada para conta ${accountId}:`, error.message);
    throw error;
  }
}

/**
 * Sincroniza ordens abertas com a corretora
 * @param {number} accountId - ID da conta
 */
async function syncOrdersWithExchange(accountId) {
  try {
    const db = await getDatabaseInstance();
    if (!db) {
      throw new Error(`Falha ao conectar ao banco para conta ${accountId}`);
    }

    console.log(`[SYNC_ORDERS] üîÑ Iniciando sincroniza√ß√£o de ordens para conta ${accountId}...`);

    // ‚úÖ DEFINIR STATUS FINALIZADOS QUE DEVEM SER MOVIDOS
    const finalizedStatuses = ['FILLED', 'CANCELED', 'CANCELLED', 'EXPIRED', 'REJECTED'];

    // Obter todos os s√≠mbolos com posi√ß√£o aberta OU j√° conhecidos no banco
    const [symbolsRows] = await db.query(
      `SELECT DISTINCT simbolo FROM posicoes WHERE conta_id = ?`, [accountId]
    );
    const symbols = symbolsRows.map(r => r.simbolo);

    let syncStats = {
      ordersChecked: 0,
      ordersInserted: 0,
      ordersUpdated: 0,
      ordersMoved: 0,
      positionsLinked: 0
    };

    for (const symbol of symbols) {
      // Buscar ordens abertas na corretora para o s√≠mbolo
      const openOrders = await getOpenOrders(accountId, symbol);
      console.log(`[SYNC_ORDERS] üìã ${symbol}: ${openOrders.length} ordens na corretora`);

      for (const order of openOrders) {
        syncStats.ordersChecked++;

        // Verificar se j√° existe no banco
        const [existing] = await db.query(
          `SELECT id_externo, status FROM ordens WHERE id_externo = ? AND conta_id = ?`,
          [order.orderId, accountId]
        );

        if (existing.length === 0) {
          // ‚úÖ INSERIR ORDEM NOVA
          await db.query(
            `INSERT INTO ordens 
              (id_externo, simbolo, tipo_ordem, preco, quantidade, status, side, conta_id, data_hora_criacao, tipo_ordem_bot, last_update)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW(), ?, NOW())`,
            [
              order.orderId,
              order.symbol,
              order.type,
              order.price,
              order.origQty,
              order.status,
              order.side,
              accountId,
              order.type, // ou mapeie para tipo_ordem_bot se necess√°rio
            ]
          );
          console.log(`[SYNC_ORDERS] ‚ûï Nova ordem ${order.orderId} (${order.symbol}) inserida: ${order.status}`);
          syncStats.ordersInserted++;
        } else {
          // ‚úÖ ATUALIZAR STATUS SE NECESS√ÅRIO
          const currentStatus = existing[0].status;
          if (currentStatus !== order.status) {
            await db.query(
              `UPDATE ordens SET status = ?, last_update = NOW() WHERE id_externo = ? AND conta_id = ?`,
              [order.status, order.orderId, accountId]
            );
            console.log(`[SYNC_ORDERS] üîÑ Status atualizado ${order.orderId}: ${currentStatus} ‚Üí ${order.status}`);
            syncStats.ordersUpdated++;
          }
        }

        // ‚úÖ VERIFICAR SE DEVE MOVER PARA HIST√ìRICO (STATUS FINALIZADO)
        if (finalizedStatuses.includes(order.status)) {
          console.log(`[SYNC_ORDERS] üéØ Status finalizado detectado: ${order.orderId} (${order.status}) - movendo para hist√≥rico...`);
          
          try {
            // ‚úÖ IMPORTAR E USAR A FUN√á√ÉO DE MOVIMENTO AUTOM√ÅTICO
            const { autoMoveOrderOnCompletion } = require('./orderHandlers');
            const moved = await autoMoveOrderOnCompletion(order.orderId, order.status, accountId);
            
            if (moved) {
              syncStats.ordersMoved++;
              console.log(`[SYNC_ORDERS] ‚úÖ Ordem ${order.orderId} (${order.status}) movida para ordens_fechadas`);
            } else {
              console.warn(`[SYNC_ORDERS] ‚ö†Ô∏è Falha ao mover ordem ${order.orderId} para hist√≥rico`);
            }
          } catch (moveError) {
            console.error(`[SYNC_ORDERS] ‚ùå Erro ao mover ordem ${order.orderId}:`, moveError.message);
          }
        } else {
          // ‚úÖ PARA ORDENS ATIVAS, ASSOCIAR id_posicao CORRETO
          const [posRows] = await db.query(
            `SELECT id FROM posicoes WHERE simbolo = ? AND status = 'OPEN' AND conta_id = ? LIMIT 1`,
            [order.symbol, accountId]
          );
          
          if (posRows.length > 0) {
            const posId = posRows[0].id;
            const [updateResult] = await db.query(
              `UPDATE ordens SET id_posicao = ? WHERE id_externo = ? AND conta_id = ? AND (id_posicao IS NULL OR id_posicao != ?)`,
              [posId, order.orderId, accountId, posId]
            );
            
            if (updateResult.affectedRows > 0) {
              syncStats.positionsLinked++;
              console.log(`[SYNC_ORDERS] üîó Ordem ${order.orderId} vinculada √† posi√ß√£o ${posId} (${order.symbol})`);
            }
          }
        }
      }
    }

    // ‚úÖ VERIFICAR ORDENS NO BANCO QUE N√ÉO EXISTEM MAIS NA CORRETORA
    console.log(`[SYNC_ORDERS] üîç Verificando ordens √≥rf√£s no banco...`);
    
    const [dbOrders] = await db.query(`
      SELECT id_externo, simbolo, status, tipo_ordem_bot
      FROM ordens 
      WHERE conta_id = ? AND status NOT IN (${finalizedStatuses.map(() => '?').join(',')})
    `, [accountId, ...finalizedStatuses]);

    let orphanCount = 0;
    for (const dbOrder of dbOrders) {
      // Verificar se ordem ainda existe na corretora
      const { getOrderStatus } = require('../api/rest');
      try {
        const orderStatus = await getOrderStatus(dbOrder.simbolo, dbOrder.id_externo, accountId);
        
        if (!orderStatus || !orderStatus.orderId) {
          // ‚úÖ ORDEM N√ÉO EXISTE MAIS NA CORRETORA - MARCAR COMO CANCELED E MOVER
          console.log(`[SYNC_ORDERS] üóëÔ∏è Ordem √≥rf√£ detectada: ${dbOrder.id_externo} - marcando como CANCELED`);
          
          await db.query(`
            UPDATE ordens 
            SET status = 'CANCELED', 
                last_update = NOW(),
                observacao = CONCAT(
                  IFNULL(observacao, ''), 
                  ' | √ìrf√£ - n√£o existe na corretora (sync)'
                )
            WHERE id_externo = ? AND conta_id = ?
          `, [dbOrder.id_externo, accountId]);
          
          // Mover para hist√≥rico
          const { autoMoveOrderOnCompletion } = require('./orderHandlers');
          const moved = await autoMoveOrderOnCompletion(dbOrder.id_externo, 'CANCELED', accountId);
          
          if (moved) {
            orphanCount++;
            console.log(`[SYNC_ORDERS] ‚úÖ Ordem √≥rf√£ ${dbOrder.id_externo} movida para hist√≥rico`);
          }
        } else if (finalizedStatuses.includes(orderStatus.status)) {
          // ‚úÖ ORDEM FINALIZADA NA CORRETORA MAS AINDA ATIVA NO BANCO
          console.log(`[SYNC_ORDERS] üéØ Ordem ${dbOrder.id_externo} finalizada na corretora (${orderStatus.status}) - atualizando e movendo...`);
          
          await db.query(`
            UPDATE ordens 
            SET status = ?, last_update = NOW()
            WHERE id_externo = ? AND conta_id = ?
          `, [orderStatus.status, dbOrder.id_externo, accountId]);
          
          const { autoMoveOrderOnCompletion } = require('./orderHandlers');
          const moved = await autoMoveOrderOnCompletion(dbOrder.id_externo, orderStatus.status, accountId);
          
          if (moved) {
            syncStats.ordersMoved++;
            console.log(`[SYNC_ORDERS] ‚úÖ Ordem atrasada ${dbOrder.id_externo} (${orderStatus.status}) movida para hist√≥rico`);
          }
        }
      } catch (checkError) {
        console.warn(`[SYNC_ORDERS] ‚ö†Ô∏è Erro ao verificar ordem ${dbOrder.id_externo}:`, checkError.message);
      }
    }

    // ‚úÖ RELAT√ìRIO FINAL
    console.log(`[SYNC_ORDERS] ‚úÖ Sincroniza√ß√£o conclu√≠da para conta ${accountId}:`);
    console.log(`[SYNC_ORDERS]   üìä Ordens verificadas: ${syncStats.ordersChecked}`);
    console.log(`[SYNC_ORDERS]   ‚ûï Ordens inseridas: ${syncStats.ordersInserted}`);
    console.log(`[SYNC_ORDERS]   üîÑ Ordens atualizadas: ${syncStats.ordersUpdated}`);
    console.log(`[SYNC_ORDERS]   üìö Ordens movidas para hist√≥rico: ${syncStats.ordersMoved}`);
    console.log(`[SYNC_ORDERS]   üîó Posi√ß√µes vinculadas: ${syncStats.positionsLinked}`);
    console.log(`[SYNC_ORDERS]   üóëÔ∏è √ìrf√£s processadas: ${orphanCount}`);

    return {
      success: true,
      stats: syncStats,
      orphansProcessed: orphanCount
    };

  } catch (error) {
    console.error(`[SYNC_ORDERS] ‚ùå Erro ao sincronizar ordens para conta ${accountId}:`, error.message);
    throw error;
  }
}

// LINHA 164 - Fun√ß√£o pad com valida√ß√£o
function pad(str, width, char = ' ') {
  // ‚úÖ VALIDA√á√ÉO: Garantir que width seja positivo
  const validWidth = Math.max(0, width || 0);
  const strLength = String(str).length;
  
  if (strLength >= validWidth) {
    return String(str);
  }
  
  const paddingNeeded = validWidth - strLength;
  return String(str) + char.repeat(paddingNeeded);
}

// LINHA 174 - Usar a fun√ß√£o pad corrigida
function logOpenPositionsAndOrdersVisual(exchangePositions, dbPositions, exchangeOrders, dbOrders) {
  try {
    console.log(`[CONTA-1] ===  VISUALIZA√á√ÉO DE POSI√á√ïES E ORDENS ===`);
    
    // ‚úÖ VALIDA√á√ÉO: Garantir que arrays existam
    const safeExchangePos = Array.isArray(exchangePositions) ? exchangePositions : [];
    const safeDbPos = Array.isArray(dbPositions) ? dbPositions : [];
    const safeExchangeOrders = Array.isArray(exchangeOrders) ? exchangeOrders : [];
    const safeDbOrders = Array.isArray(dbOrders) ? dbOrders : [];
    
    // ‚úÖ CALCULA√á√ÉO SEGURA DE LARGURA
    const maxWidth = 15; // Largura fixa m√°xima
    const minWidth = 10;  // Largura m√≠nima
    
    console.log(`[CONTA-1] Banco:   |${pad('', maxWidth)}| ${safeDbPos.length} posi√ß√µes`);
    console.log(`Corretora:|${pad('', maxWidth)}| ${safeExchangePos.length} posi√ß√µes`);
    
    // ‚úÖ LOGS ADICIONAIS DE DEBUG (opcional)
    console.log(`[CONTA-1] [SYNC] DEBUG - exchangePositions: ${safeExchangePos.length}, dbPositions: ${safeDbPos.length}`);
    console.log(`[CONTA-1] [SYNC] DEBUG - exchangeOrders: ${safeExchangeOrders.length}, dbOrders: ${safeDbOrders.length}`);
    
  } catch (error) {
    console.error(`[CONTA-1] ‚ùå Erro na visualiza√ß√£o de posi√ß√µes:`, error.message);
    console.log(`[CONTA-1] Fallback: ${exchangePositions?.length || 0} posi√ß√µes na corretora, ${dbPositions?.length || 0} no banco`);
  }
}

module.exports = {
  syncPositionsWithExchange,
  logOpenPositionsAndOrdersVisual,
  syncPositionsWithAutoClose,
  syncOrdersWithExchange
};