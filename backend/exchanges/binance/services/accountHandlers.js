const { getDatabaseInstance, insertPosition, formatDateForMySQL } = require('../../../core/database/conexao');
const websockets = require('../api/websocket');
const { sendTelegramMessage, formatBalanceMessage, formatAlertMessage } = require('./telegramBot');

/**
 * Processa atualiza√ß√µes de conta via WebSocket (ACCOUNT_UPDATE)
 * @param {Object} message - Mensagem completa do WebSocket
 * @param {number} accountId - ID da conta
 * @param {Object} db - Conex√£o com banco (opcional)
 */
async function handleAccountUpdate(message, accountId, db = null) {
  try {
    // VALIDA√á√ÉO CR√çTICA: Par√¢metros obrigat√≥rios
    if (!message || !message.a) {
      console.warn(`[ACCOUNT] Mensagem ACCOUNT_UPDATE inv√°lida para conta ${accountId}:`, {
        hasMessage: !!message,
        hasData: !!(message && message.a),
        eventType: message?.e
      });
      return;
    }

    if (!accountId || typeof accountId !== 'number') {
      console.error(`[ACCOUNT] AccountId inv√°lido: ${accountId} (tipo: ${typeof accountId})`);
      return;
    }

    const updateData = message.a;
    const reason = updateData.m || 'UNKNOWN';
    const eventTime = message.E || Date.now();
    const transactionTime = message.T || Date.now();
    
    console.log(`[ACCOUNT] ‚úÖ Atualiza√ß√£o de conta recebida para conta ${accountId}`);
    console.log(`[ACCOUNT] üìã Detalhes: Motivo=${reason}, EventTime=${eventTime}, TransactionTime=${transactionTime}`);

    // OBTER CONEX√ÉO COM BANCO
    let connection = db;
    if (!connection) {
      connection = await getDatabaseInstance(accountId);
      if (!connection) {
        console.error(`[ACCOUNT] ‚ùå N√£o foi poss√≠vel obter conex√£o com banco para conta ${accountId}`);
        return;
      }
    }

    // PROCESSAR ATUALIZA√á√ïES DE SALDO (se existir)
    if (updateData.B && Array.isArray(updateData.B) && updateData.B.length > 0) {
      console.log(`[ACCOUNT] üí∞ Processando ${updateData.B.length} atualiza√ß√µes de saldo...`);
      await handleBalanceUpdates(connection, updateData.B, accountId, reason);
    }

    // PROCESSAR ATUALIZA√á√ïES DE POSI√á√ÉO (PRINCIPAL)
    if (updateData.P && Array.isArray(updateData.P) && updateData.P.length > 0) {
      console.log(`[ACCOUNT] üìä Processando ${updateData.P.length} atualiza√ß√µes de posi√ß√£o...`);
      await handlePositionUpdates(connection, updateData.P, accountId, reason, eventTime);
    }

    // LOG DE FINALIZA√á√ÉO
    if (!updateData.B && !updateData.P) {
      console.log(`[ACCOUNT] ‚ÑπÔ∏è ACCOUNT_UPDATE sem dados de saldo ou posi√ß√£o para conta ${accountId} (motivo: ${reason})`);
    }

  } catch (error) {
    console.error(`[ACCOUNT] ‚ùå ERRO CR√çTICO ao processar atualiza√ß√£o da conta ${accountId}:`, {
      error: error.message,
      stack: error.stack?.split('\n')?.[0],
      messageType: message?.e,
      reason: message?.a?.m
    });
  }
}

/**
 * Processa atualiza√ß√µes de saldo - VERS√ÉO MELHORADA
 */
async function handleBalanceUpdates(connection, balances, accountId, reason) {
  try {
    console.log(`[ACCOUNT] üí∞ Processando ${balances.length} atualiza√ß√µes de saldo para conta ${accountId} (motivo: ${reason})`);
    
    for (const balance of balances) {
      const asset = balance.a;
      const walletBalance = parseFloat(balance.wb || '0');
      const crossWalletBalance = parseFloat(balance.cw || '0');
      const balanceChange = parseFloat(balance.bc || '0');
      
      // LOG DETALHADO APENAS PARA MUDAN√áAS SIGNIFICATIVAS
      if (Math.abs(balanceChange) > 0.001 || reason === 'FUNDING_FEE') {
        console.log(`[ACCOUNT] üí∞ ${asset}: Wallet=${walletBalance.toFixed(4)}, Cross=${crossWalletBalance.toFixed(4)}, Change=${balanceChange >= 0 ? '+' : ''}${balanceChange.toFixed(4)}`);
      }
      
      // ATUALIZAR SALDO USDT NA TABELA CONTAS
      if (asset === 'USDT' && Math.abs(balanceChange) > 0.001) {
        try {
          const [currentData] = await connection.query(
            'SELECT saldo, saldo_base_calculo FROM contas WHERE id = ?',
            [accountId]
          );
          
          const previousBalance = currentData.length > 0 ? parseFloat(currentData[0].saldo || '0') : 0;
          const previousBaseCalculo = currentData.length > 0 ? parseFloat(currentData[0].saldo_base_calculo || '0') : 0;
          const calculoBasadaEm5Porcento = crossWalletBalance * 0.05;
          const novaBaseCalculo = Math.max(calculoBasadaEm5Porcento, previousBaseCalculo);
          
          await connection.query(
            `UPDATE contas SET 
             saldo = ?,
             saldo_base_calculo = ?,
             ultima_atualizacao = NOW()
             WHERE id = ?`,
            [walletBalance, novaBaseCalculo, accountId]
          );
          
          console.log(`[ACCOUNT] ‚úÖ Saldo USDT atualizado: ${walletBalance.toFixed(2)} (base: ${novaBaseCalculo.toFixed(2)})`);
          
          // ‚úÖ NOTIFICA√á√ÉO TELEGRAM PARA MUDAN√áAS SIGNIFICATIVAS
          if (Math.abs(balanceChange) > 10 || reason === 'REALIZED_PNL') { // Mudan√ßas > $10 ou PnL realizado
            try {
              const message = formatBalanceMessage(accountId, previousBalance, walletBalance, reason);
              await sendTelegramMessage(accountId, message);
              console.log(`[ACCOUNT] üì± Notifica√ß√£o de saldo enviada`);
            } catch (telegramError) {
              console.warn(`[ACCOUNT] ‚ö†Ô∏è Erro ao enviar notifica√ß√£o de saldo:`, telegramError.message);
            }
          }
          
        } catch (updateError) {
          console.error(`[ACCOUNT] ‚ùå Erro ao atualizar saldo USDT para conta ${accountId}:`, updateError.message);
        }
      }
    }
    
  } catch (error) {
    console.error(`[ACCOUNT] ‚ùå Erro ao processar atualiza√ß√µes de saldo:`, error.message);
  }
}

/**
 * Processa atualiza√ß√µes de posi√ß√µes - VERS√ÉO CORRIGIDA SEM OBSERVACOES E SEM VALIDA√á√ÉO DE PRE√áO M√çNIMO
 */
async function handlePositionUpdates(connection, positions, accountId, reason, eventTime) {
  for (const positionData of positions) {
    const symbol = positionData.s;
    const positionAmt = parseFloat(positionData.pa || '0');
    
    if (Math.abs(positionAmt) > 0.000001) {
      // POSI√á√ÉO ABERTA OU AUMENTADA
      
      // Verificar se √© nova posi√ß√£o
      const [existingPositions] = await connection.query(
        'SELECT id FROM posicoes WHERE simbolo = ? AND status = ? AND conta_id = ?',
        [symbol, 'OPEN', accountId]
      );
      
      if (existingPositions.length === 0) {
        // ‚úÖ NOVA POSI√á√ÉO - BUSCAR SINAL ORIGINAL
        const [recentSignal] = await connection.query(`
          SELECT id, side, leverage 
          FROM webhook_signals 
          WHERE symbol = ? AND status IN ('ENTRADA_EM_PROGRESSO', 'EXECUTADO') 
          AND created_at > DATE_SUB(NOW(), INTERVAL 10 MINUTE)
          ORDER BY id DESC LIMIT 1
        `, [symbol]);
        
        const positionData = {
          simbolo: symbol,
          quantidade: Math.abs(positionAmt),
          preco_medio: parseFloat(positionData.ep || '0'),
          status: 'OPEN',
          data_hora_abertura: formatDateForMySQL(new Date()),
          side: positionAmt > 0 ? 'BUY' : 'SELL',
          leverage: recentSignal[0]?.leverage || 1,
          data_hora_ultima_atualizacao: formatDateForMySQL(new Date()),
          preco_entrada: parseFloat(positionData.ep || '0'),
          preco_corrente: parseFloat(positionData.ep || '0'),
          orign_sig: recentSignal[0] ? `WEBHOOK_${recentSignal[0].id}` : null,
          quantidade_aberta: Math.abs(positionAmt),
          conta_id: accountId
        };
        
        const newPositionId = await insertPosition(connection, positionData, recentSignal[0]?.id);
        console.log(`[ACCOUNT_UPDATE] ‚úÖ Nova posi√ß√£o criada via webhook: ${symbol} (ID: ${newPositionId})`);
        
        // Atualizar sinal com position_id
        if (recentSignal[0]) {
          await connection.query(
            `UPDATE webhook_signals SET position_id = ? WHERE id = ?`,
            [newPositionId, recentSignal[0].id]
          );
        }
      }
    }
  }
}

/**
 * Registra os handlers de conta para uma conta espec√≠fica
 */
function registerAccountHandlers(accountId) {
  try {
    console.log(`[ACCOUNT-HANDLERS] Registrando handlers de conta para conta ${accountId}...`);
    
    // VERIFICAR SE J√Å EXISTE handleAccountUpdate nos callbacks
    const existingCallbacks = websockets.getHandlers(accountId) || {};
    
    const accountCallbacks = {
      ...existingCallbacks, // Manter callbacks existentes (como handleOrderUpdate)
      handleAccountUpdate: (message, db) => handleAccountUpdate(message, accountId, db)
    };
    
    websockets.setMonitoringCallbacks(accountCallbacks, accountId);
    
    console.log(`[ACCOUNT-HANDLERS] ‚úÖ Handlers de conta registrados para conta ${accountId}`);
    return true;
    
  } catch (error) {
    console.error(`[ACCOUNT-HANDLERS] ‚ùå Erro ao registrar handlers de conta para conta ${accountId}:`, error.message);
    return false;
  }
}

/**
 * Verifica se os handlers de conta est√£o registrados
 */
function areAccountHandlersRegistered(accountId) {
  try {
    const handlers = websockets.getHandlers(accountId);
    const hasAccountHandler = handlers && typeof handlers.handleAccountUpdate === 'function';
    
    console.log(`[ACCOUNT-HANDLERS] Status do handler de conta para conta ${accountId}: ${hasAccountHandler ? '‚úÖ' : '‚ùå'}`);
    return hasAccountHandler;
    
  } catch (error) {
    console.error(`[ACCOUNT-HANDLERS] Erro ao verificar handlers de conta para conta ${accountId}:`, error.message);
    return false;
  }
}

/**
 * Remove os handlers de conta
 */
function unregisterAccountHandlers(accountId) {
  try {
    console.log(`[ACCOUNT-HANDLERS] Removendo handlers de conta para conta ${accountId}...`);
    
    // MANTER outros callbacks, remover apenas handleAccountUpdate
    const existingCallbacks = websockets.getHandlers(accountId) || {};
    const cleanedCallbacks = { ...existingCallbacks };
    delete cleanedCallbacks.handleAccountUpdate;
    
    websockets.setMonitoringCallbacks(cleanedCallbacks, accountId);
    
    console.log(`[ACCOUNT-HANDLERS] ‚úÖ Handlers de conta removidos para conta ${accountId}`);
    return true;
    
  } catch (error) {
    console.error(`[ACCOUNT-HANDLERS] Erro ao remover handlers de conta para conta ${accountId}:`, error.message);
    return false;
  }
}

/**
 * Inicializa completamente o sistema de handlers de conta
 */
async function initializeAccountHandlers(accountId) {
  try {
    console.log(`[ACCOUNT-HANDLERS] Inicializando sistema de handlers de conta para conta ${accountId}...`);
    
    // VERIFICAR CONEX√ÉO COM BANCO
    const db = await getDatabaseInstance(accountId);
    if (!db) {
      throw new Error(`N√£o foi poss√≠vel conectar ao banco para conta ${accountId}`);
    }
    
    // REGISTRAR HANDLERS
    const registered = registerAccountHandlers(accountId);
    if (!registered) {
      throw new Error(`Falha ao registrar handlers de conta para conta ${accountId}`);
    }
    
    // VERIFICAR SE FORAM REGISTRADOS CORRETAMENTE
    const verified = areAccountHandlersRegistered(accountId);
    if (!verified) {
      throw new Error(`Handlers de conta n√£o foram registrados corretamente para conta ${accountId}`);
    }
    
    console.log(`[ACCOUNT-HANDLERS] ‚úÖ Sistema de handlers de conta inicializado com sucesso para conta ${accountId}`);
    return true;
    
  } catch (error) {
    console.error(`[ACCOUNT-HANDLERS] ‚ùå Erro ao inicializar sistema de handlers de conta para conta ${accountId}:`, error.message);
    return false;
  }
}

module.exports = {
  handleAccountUpdate,
  handleBalanceUpdates,
  handlePositionUpdates,
  registerAccountHandlers,
  areAccountHandlersRegistered,
  unregisterAccountHandlers,
  initializeAccountHandlers
};