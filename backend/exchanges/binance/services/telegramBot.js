const { Telegraf } = require("telegraf");
const { getDatabaseInstance } = require('../../../core/database/conexao');

// Mapa simples para bots
const activeBots = new Map();

/**
 * ‚úÖ INICIALIZA√á√ÉO SIMPLIFICADA BASEADA NO STARBOY_DEV
 */
async function initializeTelegramBot(accountId, forceRestart = false) {
  try {
    console.log(`[TELEGRAM] üöÄ Inicializando bot SIMPLIFICADO para conta ${accountId}...`);
    
    // Validar accountId
    if (!accountId || typeof accountId !== 'number') {
      throw new Error(`AccountId inv√°lido: ${accountId} (tipo: ${typeof accountId})`);
    }
    
    // Limpar bot existente se necess√°rio
    if (forceRestart && activeBots.has(accountId)) {
      const existingBot = activeBots.get(accountId);
      try {
        if (existingBot && typeof existingBot.stop === 'function') {
          await existingBot.stop();
        }
      } catch (stopError) {
        console.warn(`[TELEGRAM] ‚ö†Ô∏è Erro ao parar bot existente:`, stopError.message);
      }
      activeBots.delete(accountId);
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    
    // Verificar se j√° existe e est√° funcional
    if (!forceRestart && activeBots.has(accountId)) {
      const existingBot = activeBots.get(accountId);
      try {
        await existingBot.telegram.getMe();
        console.log(`[TELEGRAM] ‚ôªÔ∏è Bot existente funcional para conta ${accountId}`);
        return existingBot;
      } catch (testError) {
        console.warn(`[TELEGRAM] ‚ö†Ô∏è Bot existente n√£o funcional, recriando...`);
        activeBots.delete(accountId);
      }
    }
    
    // Obter configura√ß√µes do banco
    console.log(`[TELEGRAM] üìä Obtendo configura√ß√µes para conta ${accountId}...`);
    const db = await getDatabaseInstance();
    const [rows] = await db.query(
      'SELECT telegram_bot_token, telegram_chat_id, nome FROM contas WHERE id = ? AND ativa = 1',
      [accountId]
    );
    
    if (rows.length === 0) {
      throw new Error(`Conta ${accountId} n√£o encontrada ou inativa`);
    }
    
    const { telegram_bot_token: token, telegram_chat_id: chatId, nome: accountName } = rows[0];
    
    if (!token || token.trim() === '') {
      console.warn(`[TELEGRAM] ‚ö†Ô∏è Token n√£o configurado para conta ${accountId} (${accountName})`);
      return null;
    }
    
    console.log(`[TELEGRAM] üìã Conta: ${accountName}, Chat ID: ${chatId || 'n√£o configurado'}`);
    
    // Validar token primeiro
    console.log(`[TELEGRAM] üîç Validando token...`);
    const response = await fetch(`https://api.telegram.org/bot${token}/getMe`);
    const result = await response.json();
    
    if (!result.ok) {
      throw new Error(`Token inv√°lido: ${result.description}`);
    }
    
    console.log(`[TELEGRAM] ‚úÖ Token v√°lido: @${result.result.username}`);
    
    // Limpar webhook
    try {
      await fetch(`https://api.telegram.org/bot${token}/deleteWebhook`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ drop_pending_updates: true })
      });
      console.log(`[TELEGRAM] üßπ Webhook limpo`);
    } catch (webhookError) {
      console.warn(`[TELEGRAM] ‚ö†Ô∏è Erro ao limpar webhook:`, webhookError.message);
    }
    
    // ‚úÖ CRIAR BOT SEM POLLING AUTOM√ÅTICO (COMO NO _DEV)
    const bot = new Telegraf(token);
    
    // Configurar handlers b√°sicos
    bot.start(async (ctx) => {
      try {
        const welcomeMsg = `ü§ñ Bot da conta ${accountName} ativo!\n\n` +
                         `üìä Conta ID: ${accountId}\n` +
                         `üë§ Usu√°rio: ${ctx.from.username || ctx.from.first_name}\n` +
                         `üÜî Chat ID: ${ctx.chat.id}\n\n` +
                         `Digite /help para comandos dispon√≠veis.`;
        
        await ctx.reply(welcomeMsg);
        
        // Salvar chat ID se necess√°rio
        if (!chatId) {
          await db.query(
            'UPDATE contas SET telegram_chat_id = ? WHERE id = ?',
            [ctx.chat.id, accountId]
          );
          console.log(`[TELEGRAM] ‚úÖ Chat ID salvo: ${ctx.chat.id}`);
        }
      } catch (error) {
        console.error(`[TELEGRAM] Erro no /start:`, error.message);
      }
    });
    
    bot.command('ping', (ctx) => ctx.reply('üèì Pong!'));
    bot.command('status', (ctx) => {
      const statusMsg = `‚úÖ Bot ativo - Conta ${accountName}\n‚è∞ ${new Date().toLocaleString('pt-BR')}`;
      ctx.reply(statusMsg);
    });
    
    bot.catch((err) => {
      console.error(`[TELEGRAM] Bot error:`, err.message);
    });
    
    // ‚úÖ IMPLEMENTAR POLLING MANUAL COMO FALLBACK
    let isPolling = false;
    let offset = 0;
    
    const startManualPolling = async () => {
      if (isPolling) return;
      isPolling = true;
      
      console.log(`[TELEGRAM] üîÑ Iniciando polling manual...`);
      
      while (isPolling) {
        try {
          const updates = await bot.telegram.getUpdates({
            offset: offset,
            limit: 10,
            timeout: 3
          });
          
          for (const update of updates) {
            offset = update.update_id + 1;
            
            try {
              await bot.handleUpdate(update);
            } catch (updateError) {
              console.error(`[TELEGRAM] Erro ao processar update:`, updateError.message);
            }
          }
          
          // Pequena pausa
          await new Promise(resolve => setTimeout(resolve, 1000));
          
        } catch (pollingError) {
          if (isPolling) {
            console.error(`[TELEGRAM] Erro no polling manual:`, pollingError.message);
            await new Promise(resolve => setTimeout(resolve, 5000));
          }
        }
      }
    };
    
    // Adicionar m√©todo para parar o polling
    bot.stopManualPolling = () => {
      console.log(`[TELEGRAM] üõë Parando polling manual...`);
      isPolling = false;
    };
    
    // ‚úÖ TENTAR POLLING PADR√ÉO PRIMEIRO, COM FALLBACK PARA MANUAL
    try {
      console.log(`[TELEGRAM] üöÄ Tentando polling padr√£o...`);
      
      await Promise.race([
        bot.launch({
          polling: {
            timeout: 2,
            limit: 5
          }
        }),
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Timeout padr√£o')), 5000)
        )
      ]);
      
      console.log(`[TELEGRAM] ‚úÖ Polling padr√£o funcionando!`);
      
    } catch (launchError) {
      console.log(`[TELEGRAM] ‚ö†Ô∏è Polling padr√£o falhou, usando manual: ${launchError.message}`);
      
      // Iniciar polling manual em background
      startManualPolling().catch(err => {
        console.error(`[TELEGRAM] Erro no polling manual:`, err.message);
      });
    }
    
    // Testar se bot est√° respondendo
    try {
      const botInfo = await bot.telegram.getMe();
      console.log(`[TELEGRAM] ‚úÖ Bot ativo: @${botInfo.username}`);
    } catch (testError) {
      throw new Error(`Bot n√£o est√° respondendo: ${testError.message}`);
    }
    
    // Salvar no mapa
    activeBots.set(accountId, bot);
    
    console.log(`[TELEGRAM] üéâ Bot inicializado para conta ${accountId} (${accountName})`);
    
    return bot;
    
  } catch (error) {
    console.error(`[TELEGRAM] ‚ùå Erro na inicializa√ß√£o para conta ${accountId}:`, error.message);
    throw error;
  }
}

/**
 * ‚úÖ ENVIO DIRETO VIA API (MAIS CONFI√ÅVEL)
 */
async function sendTelegramMessage(accountId, message, chatId = null) {
  try {
    console.log(`[TELEGRAM] üì§ Enviando mensagem para conta ${accountId}...`);
    
    // Obter configura√ß√µes
    const db = await getDatabaseInstance();
    const [rows] = await db.query(
      'SELECT telegram_bot_token, telegram_chat_id FROM contas WHERE id = ?',
      [accountId]
    );
    
    if (rows.length === 0) {
      throw new Error('Conta n√£o encontrada');
    }
    
    const { telegram_bot_token: token, telegram_chat_id: dbChatId } = rows[0];
    const finalChatId = chatId || dbChatId;
    
    if (!token || !finalChatId) {
      throw new Error('Token ou Chat ID n√£o configurado');
    }
    
    // ‚úÖ ENVIO DIRETO VIA API (MAIS EST√ÅVEL QUE VIA BOT)
    const response = await fetch(`https://api.telegram.org/bot${token}/sendMessage`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chat_id: finalChatId,
        text: message,
        parse_mode: 'HTML',
        disable_web_page_preview: true
      })
    });
    
    const result = await response.json();
    
    if (result.ok) {
      console.log(`[TELEGRAM] ‚úÖ Mensagem enviada com sucesso`);
      return true;
    } else {
      console.error(`[TELEGRAM] ‚ùå Erro da API:`, result.description);
      return false;
    }
    
  } catch (error) {
    console.error(`[TELEGRAM] ‚ùå Erro no envio:`, error.message);
    return false;
  }
}

/**
 * ‚úÖ PARAR BOT
 */
async function stopTelegramBot(accountId) {
  try {
    console.log(`[TELEGRAM] üõë Parando bot para conta ${accountId}...`);
    
    const bot = activeBots.get(accountId);
    if (bot) {
      try {
        // Parar polling manual se existir
        if (typeof bot.stopManualPolling === 'function') {
          bot.stopManualPolling();
        }
        
        // Parar bot
        if (typeof bot.stop === 'function') {
          await Promise.race([
            bot.stop(),
            new Promise((_, reject) => 
              setTimeout(() => reject(new Error('Stop timeout')), 3000)
            )
          ]);
        }
      } catch (stopError) {
        console.warn(`[TELEGRAM] ‚ö†Ô∏è Erro ao parar bot:`, stopError.message);
      }
      
      activeBots.delete(accountId);
      console.log(`[TELEGRAM] ‚úÖ Bot parado para conta ${accountId}`);
    } else {
      console.log(`[TELEGRAM] ‚ÑπÔ∏è Nenhum bot ativo para conta ${accountId}`);
    }
  } catch (error) {
    console.error(`[TELEGRAM] ‚ùå Erro ao parar bot:`, error.message);
  }
}

/**
 * ‚úÖ TESTE SIMPLIFICADO
 */
async function testTelegramBotFixed(accountId) {
  console.log(`[TELEGRAM_TEST] üß™ Testando vers√£o corrigida para conta ${accountId}...`);
  
  try {
    // Parar bot existente
    await stopTelegramBot(accountId);
    
    // Inicializar novo
    const bot = await initializeTelegramBot(accountId, true);
    
    if (!bot) {
      throw new Error('Falha na inicializa√ß√£o');
    }
    
    // Aguardar um momento
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Testar envio direto
    const testMessage = `üß™ <b>Teste Bot Corrigido</b>\n\n` +
                       `üè¶ Conta: ${accountId}\n` +
                       `‚è∞ ${new Date().toLocaleString('pt-BR')}\n\n` +
                       `‚úÖ Sistema funcionando!`;
    
    const messageSent = await sendTelegramMessage(accountId, testMessage);
    
    console.log(`[TELEGRAM_TEST] üìä Resultados:`);
    console.log(`[TELEGRAM_TEST] ‚úÖ Inicializa√ß√£o: Sucesso`);
    console.log(`[TELEGRAM_TEST] ${messageSent ? '‚úÖ' : '‚ùå'} Envio direto: ${messageSent ? 'Sucesso' : 'Falha'}`);
    
    return {
      success: true,
      bot: bot,
      messageSent: messageSent
    };
    
  } catch (error) {
    console.error(`[TELEGRAM_TEST] ‚ùå Teste falhou:`, error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * ‚úÖ FUN√á√ÉO PARA PARAR TODOS OS BOTS (PARA GRACEFUL SHUTDOWN)
 */
async function stopAllTelegramBots() {
  console.log(`[TELEGRAM] üõë Parando todos os bots...`);
  
  const accounts = Array.from(activeBots.keys());
  for (const accountId of accounts) {
    await stopTelegramBot(accountId);
  }
  
  console.log(`[TELEGRAM] ‚úÖ Todos os bots parados`);
}

/**
 * ‚úÖ LISTAR BOTS ATIVOS
 */
function listActiveBots() {
  console.log(`[TELEGRAM] üìã Bots ativos: ${activeBots.size}`);
  for (const [accountId, bot] of activeBots) {
    console.log(`[TELEGRAM] - Conta ${accountId}: ${bot ? 'Ativo' : 'Inativo'}`);
  }
  return Array.from(activeBots.keys());
}

/**
 * Formata mensagem de entrada executada
 */
function formatEntryMessage(signal, filledQuantity, averagePrice, totalValue) {
  const side = signal.side.toUpperCase() === 'BUY' || signal.side.toUpperCase() === 'COMPRA' ? 'üü¢ COMPRA' : 'üî¥ VENDA';
  const leverage = signal.leverage || 1;
  
  return `üéØ <b>ENTRADA EXECUTADA</b>\n\n` +
         `üìä <b>${signal.symbol}</b>\n` +
         `${side} | ${leverage}x\n\n` +
         `üí∞ <b>Execu√ß√£o:</b>\n` +
         `‚îú Quantidade: ${filledQuantity.toFixed(6)}\n` +
         `‚îú Pre√ßo m√©dio: $${averagePrice.toFixed(4)}\n` +
         `‚îî Valor total: $${totalValue.toFixed(2)}\n\n` +
         `üéØ <b>Alvos:</b>\n` +
         `‚îú üü¢ TP1: $${signal.tp1_price || 'N/A'}\n` +
         `‚îú üü¢ TP2: $${signal.tp2_price || 'N/A'}\n` +
         `‚îú üü¢ TP3: $${signal.tp3_price || 'N/A'}\n` +
         `‚îî üî¥ SL: $${signal.sl_price || 'N/A'}\n\n` +
         `‚è∞ ${new Date().toLocaleString('pt-BR')}`;
}

/**
 * Formata mensagem de erro
 */
function formatErrorMessage(signal, errorMsg) {
  const side = signal.side.toUpperCase() === 'BUY' || signal.side.toUpperCase() === 'COMPRA' ? 'üü¢ COMPRA' : 'üî¥ VENDA';
  
  return `‚ùå <b>ERRO NA ENTRADA</b>\n\n` +
         `üìä <b>${signal.symbol}</b>\n` +
         `${side} | ${signal.leverage || 1}x\n\n` +
         `üö´ <b>Motivo:</b>\n` +
         `${errorMsg}\n\n` +
         `‚è∞ ${new Date().toLocaleString('pt-BR')}`;
}

/**
 * Formata mensagem de ordem executada
 */
function formatOrderMessage(symbol, side, orderType, quantity, price, status) {
  const sideIcon = side === 'BUY' ? 'üü¢' : 'üî¥';
  const statusIcon = status === 'FILLED' ? '‚úÖ' : status === 'PARTIALLY_FILLED' ? 'üîÑ' : 'üìã';
  
  return `${statusIcon} <b>ORDEM ${status}</b>\n\n` +
         `üìä <b>${symbol}</b>\n` +
         `${sideIcon} ${side} ${orderType}\n\n` +
         `üí∞ <b>Detalhes:</b>\n` +
         `‚îú Quantidade: ${quantity}\n` +
         `‚îî Pre√ßo: $${price}\n\n` +
         `‚è∞ ${new Date().toLocaleString('pt-BR')}`;
}

/**
 * Formata mensagem de mudan√ßa de saldo
 */
function formatBalanceMessage(accountId, previousBalance, newBalance, reason, balanceChange = null) {
  const change = balanceChange !== null ? balanceChange : (newBalance - previousBalance);
  const changeText = change >= 0 ? `+${change.toFixed(4)}` : change.toFixed(4);
  const emoji = change >= 0 ? 'üìà' : 'üìâ';
  
  let reasonText = reason;
  switch (reason) {
    case 'FUNDING_FEE':
      reasonText = 'Taxa de Financiamento';
      break;
    case 'REALIZED_PNL':
      reasonText = 'PnL Realizado';
      break;
    case 'ORDER':
      reasonText = 'Execu√ß√£o de Ordem';
      break;
    case 'COMMISSION':
      reasonText = 'Comiss√£o';
      break;
    default:
      reasonText = reason;
  }
  
  return `${emoji} **Atualiza√ß√£o de Saldo**
  
üí∞ **Saldo Anterior:** ${previousBalance.toFixed(2)} USDT
üí∞ **Novo Saldo:** ${newBalance.toFixed(2)} USDT
üìä **Mudan√ßa:** ${changeText} USDT

üîç **Motivo:** ${reasonText}
üìã **Conta:** ${accountId}
‚è∞ **Hor√°rio:** ${new Date().toLocaleString('pt-BR')}`;
}

/**
 * Formata mensagem de posi√ß√£o fechada
 */
function formatPositionClosedMessage(symbol, side, quantity, entryPrice, exitPrice, pnl) {
  const pnlIcon = pnl >= 0 ? 'üí∞' : 'üí∏';
  const pnlColor = pnl >= 0 ? 'üü¢' : 'üî¥';
  const sideIcon = side === 'BUY' ? 'üü¢' : 'üî¥';
  
  return `${pnlIcon} <b>POSI√á√ÉO FECHADA</b>\n\n` +
         `üìä <b>${symbol}</b>\n` +
         `${sideIcon} ${side}\n\n` +
         `üí∞ <b>Resultado:</b>\n` +
         `‚îú Quantidade: ${quantity}\n` +
         `‚îú Entrada: $${entryPrice.toFixed(4)}\n` +
         `‚îú Sa√≠da: $${exitPrice.toFixed(4)}\n` +
         `‚îî ${pnlColor} PnL: ${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)}\n\n` +
         `‚è∞ ${new Date().toLocaleString('pt-BR')}`;
}

/**
 * Formata mensagem de alerta
 */
function formatAlertMessage(title, message, level = 'INFO') {
  const icons = {
    'INFO': '‚ÑπÔ∏è',
    'WARNING': '‚ö†Ô∏è',
    'ERROR': '‚ùå',
    'SUCCESS': '‚úÖ'
  };
  
  return `${icons[level] || '‚ÑπÔ∏è'} <b>${title}</b>\n\n${message}\n\n‚è∞ ${new Date().toLocaleString('pt-BR')}`;
}

// ‚úÖ ATUALIZAR module.exports PARA INCLUIR AS NOVAS FUN√á√ïES:
module.exports = {
  initializeTelegramBot,
  sendTelegramMessage,
  stopTelegramBot,
  testTelegramBotFixed,
  stopAllTelegramBots,
  listActiveBots,
  // ‚úÖ NOVAS FUN√á√ïES DE FORMATA√á√ÉO:
  formatEntryMessage,
  formatErrorMessage,
  formatOrderMessage,
  formatBalanceMessage,
  formatPositionClosedMessage,
  formatAlertMessage
};